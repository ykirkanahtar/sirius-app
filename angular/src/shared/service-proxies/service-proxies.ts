//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.1.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isTenantAvailable(body: IsTenantAvailableInput | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IsTenantAvailableOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IsTenantAvailableOutput>;
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IsTenantAvailableOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterInput | undefined): Observable<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegisterOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegisterOutput>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AccountBookServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateAccountBookDto | undefined): Observable<AccountBookDto> {
        let url_ = this.baseUrl + "/api/services/app/AccountBook/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountBookDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountBookDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<AccountBookDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccountBookDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateAccountBookDto | undefined): Observable<AccountBookDto> {
        let url_ = this.baseUrl + "/api/services/app/AccountBook/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountBookDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountBookDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<AccountBookDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccountBookDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AccountBook/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<AccountBookDto> {
        let url_ = this.baseUrl + "/api/services/app/AccountBook/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountBookDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountBookDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<AccountBookDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccountBookDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param periodId (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param paymentCategoryIds (optional) 
     * @param housingIds (optional) 
     * @param personIds (optional) 
     * @param fromPaymentAccountIds (optional) 
     * @param toPaymentAccountIds (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllList(periodId: string | undefined, startDate: moment.Moment | undefined, endDate: moment.Moment | undefined, paymentCategoryIds: string[] | undefined, housingIds: string[] | undefined, personIds: string[] | undefined, fromPaymentAccountIds: string[] | undefined, toPaymentAccountIds: string[] | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedAccountBookResultDto> {
        let url_ = this.baseUrl + "/api/services/app/AccountBook/GetAllList?";
        if (periodId === null)
            throw new Error("The parameter 'periodId' cannot be null.");
        else if (periodId !== undefined)
            url_ += "PeriodId=" + encodeURIComponent("" + periodId) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (paymentCategoryIds === null)
            throw new Error("The parameter 'paymentCategoryIds' cannot be null.");
        else if (paymentCategoryIds !== undefined)
            paymentCategoryIds && paymentCategoryIds.forEach(item => { url_ += "PaymentCategoryIds=" + encodeURIComponent("" + item) + "&"; });
        if (housingIds === null)
            throw new Error("The parameter 'housingIds' cannot be null.");
        else if (housingIds !== undefined)
            housingIds && housingIds.forEach(item => { url_ += "HousingIds=" + encodeURIComponent("" + item) + "&"; });
        if (personIds === null)
            throw new Error("The parameter 'personIds' cannot be null.");
        else if (personIds !== undefined)
            personIds && personIds.forEach(item => { url_ += "PersonIds=" + encodeURIComponent("" + item) + "&"; });
        if (fromPaymentAccountIds === null)
            throw new Error("The parameter 'fromPaymentAccountIds' cannot be null.");
        else if (fromPaymentAccountIds !== undefined)
            fromPaymentAccountIds && fromPaymentAccountIds.forEach(item => { url_ += "FromPaymentAccountIds=" + encodeURIComponent("" + item) + "&"; });
        if (toPaymentAccountIds === null)
            throw new Error("The parameter 'toPaymentAccountIds' cannot be null.");
        else if (toPaymentAccountIds !== undefined)
            toPaymentAccountIds && toPaymentAccountIds.forEach(item => { url_ += "ToPaymentAccountIds=" + encodeURIComponent("" + item) + "&"; });
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedAccountBookResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedAccountBookResultDto>;
        }));
    }

    protected processGetAllList(response: HttpResponseBase): Observable<PagedAccountBookResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedAccountBookResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param periodId (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param paymentCategoryIds (optional) 
     * @param housingIds (optional) 
     * @param personIds (optional) 
     * @param fromPaymentAccountIds (optional) 
     * @param toPaymentAccountIds (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getAllListForExport(periodId: string | undefined, startDate: moment.Moment | undefined, endDate: moment.Moment | undefined, paymentCategoryIds: string[] | undefined, housingIds: string[] | undefined, personIds: string[] | undefined, fromPaymentAccountIds: string[] | undefined, toPaymentAccountIds: string[] | undefined, sorting: string | undefined): Observable<AccountBookGetAllExportOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/AccountBook/GetAllListForExport?";
        if (periodId === null)
            throw new Error("The parameter 'periodId' cannot be null.");
        else if (periodId !== undefined)
            url_ += "PeriodId=" + encodeURIComponent("" + periodId) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (paymentCategoryIds === null)
            throw new Error("The parameter 'paymentCategoryIds' cannot be null.");
        else if (paymentCategoryIds !== undefined)
            paymentCategoryIds && paymentCategoryIds.forEach(item => { url_ += "PaymentCategoryIds=" + encodeURIComponent("" + item) + "&"; });
        if (housingIds === null)
            throw new Error("The parameter 'housingIds' cannot be null.");
        else if (housingIds !== undefined)
            housingIds && housingIds.forEach(item => { url_ += "HousingIds=" + encodeURIComponent("" + item) + "&"; });
        if (personIds === null)
            throw new Error("The parameter 'personIds' cannot be null.");
        else if (personIds !== undefined)
            personIds && personIds.forEach(item => { url_ += "PersonIds=" + encodeURIComponent("" + item) + "&"; });
        if (fromPaymentAccountIds === null)
            throw new Error("The parameter 'fromPaymentAccountIds' cannot be null.");
        else if (fromPaymentAccountIds !== undefined)
            fromPaymentAccountIds && fromPaymentAccountIds.forEach(item => { url_ += "FromPaymentAccountIds=" + encodeURIComponent("" + item) + "&"; });
        if (toPaymentAccountIds === null)
            throw new Error("The parameter 'toPaymentAccountIds' cannot be null.");
        else if (toPaymentAccountIds !== undefined)
            toPaymentAccountIds && toPaymentAccountIds.forEach(item => { url_ += "ToPaymentAccountIds=" + encodeURIComponent("" + item) + "&"; });
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllListForExport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllListForExport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountBookGetAllExportOutput[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountBookGetAllExportOutput[]>;
        }));
    }

    protected processGetAllListForExport(response: HttpResponseBase): Observable<AccountBookGetAllExportOutput[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(AccountBookGetAllExportOutput.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accountBookId (optional) 
     * @return Success
     */
    getPaymentCategoryLookUpForEditAccountBook(accountBookId: string | undefined): Observable<LookUpDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AccountBook/GetPaymentCategoryLookUpForEditAccountBook?";
        if (accountBookId === null)
            throw new Error("The parameter 'accountBookId' cannot be null.");
        else if (accountBookId !== undefined)
            url_ += "accountBookId=" + encodeURIComponent("" + accountBookId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentCategoryLookUpForEditAccountBook(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentCategoryLookUpForEditAccountBook(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LookUpDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LookUpDto[]>;
        }));
    }

    protected processGetPaymentCategoryLookUpForEditAccountBook(response: HttpResponseBase): Observable<LookUpDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookUpDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param periodId (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param paymentCategoryIds (optional) 
     * @param housingIds (optional) 
     * @param personIds (optional) 
     * @param fromPaymentAccountIds (optional) 
     * @param toPaymentAccountIds (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(periodId: string | undefined, startDate: moment.Moment | undefined, endDate: moment.Moment | undefined, paymentCategoryIds: string[] | undefined, housingIds: string[] | undefined, personIds: string[] | undefined, fromPaymentAccountIds: string[] | undefined, toPaymentAccountIds: string[] | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<AccountBookDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/AccountBook/GetAll?";
        if (periodId === null)
            throw new Error("The parameter 'periodId' cannot be null.");
        else if (periodId !== undefined)
            url_ += "PeriodId=" + encodeURIComponent("" + periodId) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (paymentCategoryIds === null)
            throw new Error("The parameter 'paymentCategoryIds' cannot be null.");
        else if (paymentCategoryIds !== undefined)
            paymentCategoryIds && paymentCategoryIds.forEach(item => { url_ += "PaymentCategoryIds=" + encodeURIComponent("" + item) + "&"; });
        if (housingIds === null)
            throw new Error("The parameter 'housingIds' cannot be null.");
        else if (housingIds !== undefined)
            housingIds && housingIds.forEach(item => { url_ += "HousingIds=" + encodeURIComponent("" + item) + "&"; });
        if (personIds === null)
            throw new Error("The parameter 'personIds' cannot be null.");
        else if (personIds !== undefined)
            personIds && personIds.forEach(item => { url_ += "PersonIds=" + encodeURIComponent("" + item) + "&"; });
        if (fromPaymentAccountIds === null)
            throw new Error("The parameter 'fromPaymentAccountIds' cannot be null.");
        else if (fromPaymentAccountIds !== undefined)
            fromPaymentAccountIds && fromPaymentAccountIds.forEach(item => { url_ += "FromPaymentAccountIds=" + encodeURIComponent("" + item) + "&"; });
        if (toPaymentAccountIds === null)
            throw new Error("The parameter 'toPaymentAccountIds' cannot be null.");
        else if (toPaymentAccountIds !== undefined)
            toPaymentAccountIds && toPaymentAccountIds.forEach(item => { url_ += "ToPaymentAccountIds=" + encodeURIComponent("" + item) + "&"; });
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountBookDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountBookDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<AccountBookDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccountBookDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class BlockServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateBlockDto | undefined): Observable<BlockDto> {
        let url_ = this.baseUrl + "/api/services/app/Block/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BlockDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BlockDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<BlockDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BlockDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateBlockDto | undefined): Observable<BlockDto> {
        let url_ = this.baseUrl + "/api/services/app/Block/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BlockDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BlockDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<BlockDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BlockDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Block/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<BlockDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Block/GetAll?";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BlockDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BlockDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<BlockDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BlockDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getBlockLookUp(): Observable<LookUpDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Block/GetBlockLookUp";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBlockLookUp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBlockLookUp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LookUpDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LookUpDto[]>;
        }));
    }

    protected processGetBlockLookUp(response: HttpResponseBase): Observable<LookUpDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookUpDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<BlockDto> {
        let url_ = this.baseUrl + "/api/services/app/Block/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BlockDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BlockDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<BlockDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BlockDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ConfigurationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeUiTheme(body: ChangeUiThemeInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Configuration/ChangeUiTheme";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeUiTheme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeUiTheme(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeUiTheme(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class EmployeeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateEmployeeDto | undefined): Observable<EmployeeDto> {
        let url_ = this.baseUrl + "/api/services/app/Employee/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmployeeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmployeeDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<EmployeeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmployeeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: EmployeeDto | undefined): Observable<EmployeeDto> {
        let url_ = this.baseUrl + "/api/services/app/Employee/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmployeeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmployeeDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<EmployeeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmployeeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Employee/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param name (optional) 
     * @param phoneNumber (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(name: string | undefined, phoneNumber: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<EmployeeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Employee/GetAll?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (phoneNumber === null)
            throw new Error("The parameter 'phoneNumber' cannot be null.");
        else if (phoneNumber !== undefined)
            url_ += "PhoneNumber=" + encodeURIComponent("" + phoneNumber) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmployeeDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmployeeDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<EmployeeDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmployeeDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEmployeeLookUp(): Observable<LookUpDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Employee/GetEmployeeLookUp";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeeLookUp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeeLookUp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LookUpDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LookUpDto[]>;
        }));
    }

    protected processGetEmployeeLookUp(response: HttpResponseBase): Observable<LookUpDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookUpDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param request (optional) 
     * @return Success
     */
    getEmployeeFromAutoCompleteFilter(request: string | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/Employee/GetEmployeeFromAutoCompleteFilter?";
        if (request === null)
            throw new Error("The parameter 'request' cannot be null.");
        else if (request !== undefined)
            url_ += "request=" + encodeURIComponent("" + request) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeeFromAutoCompleteFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeeFromAutoCompleteFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetEmployeeFromAutoCompleteFilter(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<EmployeeDto> {
        let url_ = this.baseUrl + "/api/services/app/Employee/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmployeeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmployeeDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<EmployeeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmployeeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class HousingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateHousingDto | undefined): Observable<HousingDto> {
        let url_ = this.baseUrl + "/api/services/app/Housing/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HousingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HousingDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<HousingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HousingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateHousingDto | undefined): Observable<HousingDto> {
        let url_ = this.baseUrl + "/api/services/app/Housing/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HousingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HousingDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<HousingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HousingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Housing/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getHousingForUpdate(id: string | undefined): Observable<UpdateHousingDto> {
        let url_ = this.baseUrl + "/api/services/app/Housing/GetHousingForUpdate?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHousingForUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHousingForUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateHousingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateHousingDto>;
        }));
    }

    protected processGetHousingForUpdate(response: HttpResponseBase): Observable<UpdateHousingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateHousingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param housingIds (optional) 
     * @param housingCategoryIds (optional) 
     * @param personIds (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllList(housingIds: string[] | undefined, housingCategoryIds: string[] | undefined, personIds: string[] | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<HousingForListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Housing/GetAllList?";
        if (housingIds === null)
            throw new Error("The parameter 'housingIds' cannot be null.");
        else if (housingIds !== undefined)
            housingIds && housingIds.forEach(item => { url_ += "HousingIds=" + encodeURIComponent("" + item) + "&"; });
        if (housingCategoryIds === null)
            throw new Error("The parameter 'housingCategoryIds' cannot be null.");
        else if (housingCategoryIds !== undefined)
            housingCategoryIds && housingCategoryIds.forEach(item => { url_ += "HousingCategoryIds=" + encodeURIComponent("" + item) + "&"; });
        if (personIds === null)
            throw new Error("The parameter 'personIds' cannot be null.");
        else if (personIds !== undefined)
            personIds && personIds.forEach(item => { url_ += "PersonIds=" + encodeURIComponent("" + item) + "&"; });
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HousingForListDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HousingForListDtoPagedResultDto>;
        }));
    }

    protected processGetAllList(response: HttpResponseBase): Observable<HousingForListDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HousingForListDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param personId (optional) 
     * @param paymentCategoryId (optional) 
     * @return Success
     */
    getHousingLookUp(personId: string | undefined, paymentCategoryId: string | undefined): Observable<LookUpDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Housing/GetHousingLookUp?";
        if (personId === null)
            throw new Error("The parameter 'personId' cannot be null.");
        else if (personId !== undefined)
            url_ += "PersonId=" + encodeURIComponent("" + personId) + "&";
        if (paymentCategoryId === null)
            throw new Error("The parameter 'paymentCategoryId' cannot be null.");
        else if (paymentCategoryId !== undefined)
            url_ += "PaymentCategoryId=" + encodeURIComponent("" + paymentCategoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHousingLookUp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHousingLookUp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LookUpDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LookUpDto[]>;
        }));
    }

    protected processGetHousingLookUp(response: HttpResponseBase): Observable<LookUpDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookUpDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addPerson(body: CreateHousingPersonDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Housing/AddPerson";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddPerson(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddPerson(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddPerson(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param housingId (optional) 
     * @param personId (optional) 
     * @return Success
     */
    removePerson(housingId: string | undefined, personId: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Housing/RemovePerson?";
        if (housingId === null)
            throw new Error("The parameter 'housingId' cannot be null.");
        else if (housingId !== undefined)
            url_ += "HousingId=" + encodeURIComponent("" + housingId) + "&";
        if (personId === null)
            throw new Error("The parameter 'personId' cannot be null.");
        else if (personId !== undefined)
            url_ += "PersonId=" + encodeURIComponent("" + personId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemovePerson(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemovePerson(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemovePerson(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param housingId (optional) 
     * @return Success
     */
    getPeopleLookUp(housingId: string | undefined): Observable<LookUpDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Housing/GetPeopleLookUp?";
        if (housingId === null)
            throw new Error("The parameter 'housingId' cannot be null.");
        else if (housingId !== undefined)
            url_ += "housingId=" + encodeURIComponent("" + housingId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPeopleLookUp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPeopleLookUp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LookUpDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LookUpDto[]>;
        }));
    }

    protected processGetPeopleLookUp(response: HttpResponseBase): Observable<LookUpDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookUpDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param housingId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getHousingPeople(housingId: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<HousingPersonDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Housing/GetHousingPeople?";
        if (housingId === null)
            throw new Error("The parameter 'housingId' cannot be null.");
        else if (housingId !== undefined)
            url_ += "HousingId=" + encodeURIComponent("" + housingId) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHousingPeople(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHousingPeople(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HousingPersonDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HousingPersonDtoPagedResultDto>;
        }));
    }

    protected processGetHousingPeople(response: HttpResponseBase): Observable<HousingPersonDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HousingPersonDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<HousingDto> {
        let url_ = this.baseUrl + "/api/services/app/Housing/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HousingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HousingDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<HousingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HousingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param housingIds (optional) 
     * @param housingCategoryIds (optional) 
     * @param personIds (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(housingIds: string[] | undefined, housingCategoryIds: string[] | undefined, personIds: string[] | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<HousingDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Housing/GetAll?";
        if (housingIds === null)
            throw new Error("The parameter 'housingIds' cannot be null.");
        else if (housingIds !== undefined)
            housingIds && housingIds.forEach(item => { url_ += "HousingIds=" + encodeURIComponent("" + item) + "&"; });
        if (housingCategoryIds === null)
            throw new Error("The parameter 'housingCategoryIds' cannot be null.");
        else if (housingCategoryIds !== undefined)
            housingCategoryIds && housingCategoryIds.forEach(item => { url_ += "HousingCategoryIds=" + encodeURIComponent("" + item) + "&"; });
        if (personIds === null)
            throw new Error("The parameter 'personIds' cannot be null.");
        else if (personIds !== undefined)
            personIds && personIds.forEach(item => { url_ += "PersonIds=" + encodeURIComponent("" + item) + "&"; });
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HousingDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HousingDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<HousingDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HousingDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class HousingCategoryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateHousingCategoryDto | undefined): Observable<HousingCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/HousingCategory/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HousingCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HousingCategoryDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<HousingCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HousingCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateHousingCategoryDto | undefined): Observable<HousingCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/HousingCategory/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HousingCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HousingCategoryDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<HousingCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HousingCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HousingCategory/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param housingCategoryName (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(housingCategoryName: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<HousingCategoryDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/HousingCategory/GetAll?";
        if (housingCategoryName === null)
            throw new Error("The parameter 'housingCategoryName' cannot be null.");
        else if (housingCategoryName !== undefined)
            url_ += "HousingCategoryName=" + encodeURIComponent("" + housingCategoryName) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HousingCategoryDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HousingCategoryDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<HousingCategoryDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HousingCategoryDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getHousingCategoryLookUp(): Observable<LookUpDto[]> {
        let url_ = this.baseUrl + "/api/services/app/HousingCategory/GetHousingCategoryLookUp";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHousingCategoryLookUp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHousingCategoryLookUp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LookUpDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LookUpDto[]>;
        }));
    }

    protected processGetHousingCategoryLookUp(response: HttpResponseBase): Observable<LookUpDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookUpDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param request (optional) 
     * @return Success
     */
    getHousingCategoryFromAutoCompleteFilter(request: string | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/HousingCategory/GetHousingCategoryFromAutoCompleteFilter?";
        if (request === null)
            throw new Error("The parameter 'request' cannot be null.");
        else if (request !== undefined)
            url_ += "request=" + encodeURIComponent("" + request) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHousingCategoryFromAutoCompleteFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHousingCategoryFromAutoCompleteFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetHousingCategoryFromAutoCompleteFilter(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<HousingCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/HousingCategory/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HousingCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HousingCategoryDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<HousingCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HousingCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class HousingPaymentPlanServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createCreditPayment(body: CreateCreditHousingPaymentPlanDto | undefined): Observable<HousingPaymentPlanDto> {
        let url_ = this.baseUrl + "/api/services/app/HousingPaymentPlan/CreateCreditPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCreditPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCreditPayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HousingPaymentPlanDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HousingPaymentPlanDto>;
        }));
    }

    protected processCreateCreditPayment(response: HttpResponseBase): Observable<HousingPaymentPlanDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HousingPaymentPlanDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createDebtPayment(body: CreateDebtHousingPaymentPlanDto | undefined): Observable<HousingPaymentPlanDto> {
        let url_ = this.baseUrl + "/api/services/app/HousingPaymentPlan/CreateDebtPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateDebtPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateDebtPayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HousingPaymentPlanDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HousingPaymentPlanDto>;
        }));
    }

    protected processCreateDebtPayment(response: HttpResponseBase): Observable<HousingPaymentPlanDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HousingPaymentPlanDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateCreditHousingPaymentPlanDto | undefined): Observable<HousingPaymentPlanDto> {
        let url_ = this.baseUrl + "/api/services/app/HousingPaymentPlan/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HousingPaymentPlanDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HousingPaymentPlanDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<HousingPaymentPlanDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HousingPaymentPlanDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateHousingPaymentPlanDto | undefined): Observable<HousingPaymentPlanDto> {
        let url_ = this.baseUrl + "/api/services/app/HousingPaymentPlan/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HousingPaymentPlanDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HousingPaymentPlanDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<HousingPaymentPlanDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HousingPaymentPlanDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HousingPaymentPlan/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param housingId (optional) 
     * @param periodId (optional) 
     * @param startDateFilter (optional) 
     * @param endDateFilter (optional) 
     * @param paymentCategoriesFilter (optional) 
     * @param creditOrDebtsFilter (optional) 
     * @param housingPaymentPlanTypesFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllByHousingId(housingId: string | undefined, periodId: string | undefined, startDateFilter: moment.Moment | undefined, endDateFilter: moment.Moment | undefined, paymentCategoriesFilter: string[] | undefined, creditOrDebtsFilter: CreditOrDebt[] | undefined, housingPaymentPlanTypesFilter: HousingPaymentPlanType[] | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedHousingPaymentPlanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/HousingPaymentPlan/GetAllByHousingId?";
        if (housingId === null)
            throw new Error("The parameter 'housingId' cannot be null.");
        else if (housingId !== undefined)
            url_ += "HousingId=" + encodeURIComponent("" + housingId) + "&";
        if (periodId === null)
            throw new Error("The parameter 'periodId' cannot be null.");
        else if (periodId !== undefined)
            url_ += "PeriodId=" + encodeURIComponent("" + periodId) + "&";
        if (startDateFilter === null)
            throw new Error("The parameter 'startDateFilter' cannot be null.");
        else if (startDateFilter !== undefined)
            url_ += "StartDateFilter=" + encodeURIComponent(startDateFilter ? "" + startDateFilter.toISOString() : "") + "&";
        if (endDateFilter === null)
            throw new Error("The parameter 'endDateFilter' cannot be null.");
        else if (endDateFilter !== undefined)
            url_ += "EndDateFilter=" + encodeURIComponent(endDateFilter ? "" + endDateFilter.toISOString() : "") + "&";
        if (paymentCategoriesFilter === null)
            throw new Error("The parameter 'paymentCategoriesFilter' cannot be null.");
        else if (paymentCategoriesFilter !== undefined)
            paymentCategoriesFilter && paymentCategoriesFilter.forEach(item => { url_ += "PaymentCategoriesFilter=" + encodeURIComponent("" + item) + "&"; });
        if (creditOrDebtsFilter === null)
            throw new Error("The parameter 'creditOrDebtsFilter' cannot be null.");
        else if (creditOrDebtsFilter !== undefined)
            creditOrDebtsFilter && creditOrDebtsFilter.forEach(item => { url_ += "CreditOrDebtsFilter=" + encodeURIComponent("" + item) + "&"; });
        if (housingPaymentPlanTypesFilter === null)
            throw new Error("The parameter 'housingPaymentPlanTypesFilter' cannot be null.");
        else if (housingPaymentPlanTypesFilter !== undefined)
            housingPaymentPlanTypesFilter && housingPaymentPlanTypesFilter.forEach(item => { url_ += "HousingPaymentPlanTypesFilter=" + encodeURIComponent("" + item) + "&"; });
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllByHousingId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllByHousingId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedHousingPaymentPlanResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedHousingPaymentPlanResultDto>;
        }));
    }

    protected processGetAllByHousingId(response: HttpResponseBase): Observable<PagedHousingPaymentPlanResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedHousingPaymentPlanResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param housingId (optional) 
     * @param periodId (optional) 
     * @param startDateFilter (optional) 
     * @param endDateFilter (optional) 
     * @param paymentCategoriesFilter (optional) 
     * @param creditOrDebtsFilter (optional) 
     * @param housingPaymentPlanTypesFilter (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getAllByHousingIdForExport(housingId: string | undefined, periodId: string | undefined, startDateFilter: moment.Moment | undefined, endDateFilter: moment.Moment | undefined, paymentCategoriesFilter: string[] | undefined, creditOrDebtsFilter: CreditOrDebt[] | undefined, housingPaymentPlanTypesFilter: HousingPaymentPlanType[] | undefined, sorting: string | undefined): Observable<HousingPaymentPlanExportOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/HousingPaymentPlan/GetAllByHousingIdForExport?";
        if (housingId === null)
            throw new Error("The parameter 'housingId' cannot be null.");
        else if (housingId !== undefined)
            url_ += "HousingId=" + encodeURIComponent("" + housingId) + "&";
        if (periodId === null)
            throw new Error("The parameter 'periodId' cannot be null.");
        else if (periodId !== undefined)
            url_ += "PeriodId=" + encodeURIComponent("" + periodId) + "&";
        if (startDateFilter === null)
            throw new Error("The parameter 'startDateFilter' cannot be null.");
        else if (startDateFilter !== undefined)
            url_ += "StartDateFilter=" + encodeURIComponent(startDateFilter ? "" + startDateFilter.toISOString() : "") + "&";
        if (endDateFilter === null)
            throw new Error("The parameter 'endDateFilter' cannot be null.");
        else if (endDateFilter !== undefined)
            url_ += "EndDateFilter=" + encodeURIComponent(endDateFilter ? "" + endDateFilter.toISOString() : "") + "&";
        if (paymentCategoriesFilter === null)
            throw new Error("The parameter 'paymentCategoriesFilter' cannot be null.");
        else if (paymentCategoriesFilter !== undefined)
            paymentCategoriesFilter && paymentCategoriesFilter.forEach(item => { url_ += "PaymentCategoriesFilter=" + encodeURIComponent("" + item) + "&"; });
        if (creditOrDebtsFilter === null)
            throw new Error("The parameter 'creditOrDebtsFilter' cannot be null.");
        else if (creditOrDebtsFilter !== undefined)
            creditOrDebtsFilter && creditOrDebtsFilter.forEach(item => { url_ += "CreditOrDebtsFilter=" + encodeURIComponent("" + item) + "&"; });
        if (housingPaymentPlanTypesFilter === null)
            throw new Error("The parameter 'housingPaymentPlanTypesFilter' cannot be null.");
        else if (housingPaymentPlanTypesFilter !== undefined)
            housingPaymentPlanTypesFilter && housingPaymentPlanTypesFilter.forEach(item => { url_ += "HousingPaymentPlanTypesFilter=" + encodeURIComponent("" + item) + "&"; });
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllByHousingIdForExport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllByHousingIdForExport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HousingPaymentPlanExportOutput[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HousingPaymentPlanExportOutput[]>;
        }));
    }

    protected processGetAllByHousingIdForExport(response: HttpResponseBase): Observable<HousingPaymentPlanExportOutput[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(HousingPaymentPlanExportOutput.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<HousingPaymentPlanDto> {
        let url_ = this.baseUrl + "/api/services/app/HousingPaymentPlan/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HousingPaymentPlanDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HousingPaymentPlanDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<HousingPaymentPlanDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HousingPaymentPlanDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param housingId (optional) 
     * @param periodId (optional) 
     * @param startDateFilter (optional) 
     * @param endDateFilter (optional) 
     * @param paymentCategoriesFilter (optional) 
     * @param creditOrDebtsFilter (optional) 
     * @param housingPaymentPlanTypesFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(housingId: string | undefined, periodId: string | undefined, startDateFilter: moment.Moment | undefined, endDateFilter: moment.Moment | undefined, paymentCategoriesFilter: string[] | undefined, creditOrDebtsFilter: CreditOrDebt[] | undefined, housingPaymentPlanTypesFilter: HousingPaymentPlanType[] | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<HousingPaymentPlanDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/HousingPaymentPlan/GetAll?";
        if (housingId === null)
            throw new Error("The parameter 'housingId' cannot be null.");
        else if (housingId !== undefined)
            url_ += "HousingId=" + encodeURIComponent("" + housingId) + "&";
        if (periodId === null)
            throw new Error("The parameter 'periodId' cannot be null.");
        else if (periodId !== undefined)
            url_ += "PeriodId=" + encodeURIComponent("" + periodId) + "&";
        if (startDateFilter === null)
            throw new Error("The parameter 'startDateFilter' cannot be null.");
        else if (startDateFilter !== undefined)
            url_ += "StartDateFilter=" + encodeURIComponent(startDateFilter ? "" + startDateFilter.toISOString() : "") + "&";
        if (endDateFilter === null)
            throw new Error("The parameter 'endDateFilter' cannot be null.");
        else if (endDateFilter !== undefined)
            url_ += "EndDateFilter=" + encodeURIComponent(endDateFilter ? "" + endDateFilter.toISOString() : "") + "&";
        if (paymentCategoriesFilter === null)
            throw new Error("The parameter 'paymentCategoriesFilter' cannot be null.");
        else if (paymentCategoriesFilter !== undefined)
            paymentCategoriesFilter && paymentCategoriesFilter.forEach(item => { url_ += "PaymentCategoriesFilter=" + encodeURIComponent("" + item) + "&"; });
        if (creditOrDebtsFilter === null)
            throw new Error("The parameter 'creditOrDebtsFilter' cannot be null.");
        else if (creditOrDebtsFilter !== undefined)
            creditOrDebtsFilter && creditOrDebtsFilter.forEach(item => { url_ += "CreditOrDebtsFilter=" + encodeURIComponent("" + item) + "&"; });
        if (housingPaymentPlanTypesFilter === null)
            throw new Error("The parameter 'housingPaymentPlanTypesFilter' cannot be null.");
        else if (housingPaymentPlanTypesFilter !== undefined)
            housingPaymentPlanTypesFilter && housingPaymentPlanTypesFilter.forEach(item => { url_ += "HousingPaymentPlanTypesFilter=" + encodeURIComponent("" + item) + "&"; });
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HousingPaymentPlanDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HousingPaymentPlanDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<HousingPaymentPlanDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HousingPaymentPlanDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class HousingPaymentPlanGroupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateHousingPaymentPlanGroupDto | undefined): Observable<HousingPaymentPlanGroupDto> {
        let url_ = this.baseUrl + "/api/services/app/HousingPaymentPlanGroup/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HousingPaymentPlanGroupDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HousingPaymentPlanGroupDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<HousingPaymentPlanGroupDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HousingPaymentPlanGroupDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateHousingPaymentPlanGroupDto | undefined): Observable<HousingPaymentPlanGroupDto> {
        let url_ = this.baseUrl + "/api/services/app/HousingPaymentPlanGroup/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HousingPaymentPlanGroupDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HousingPaymentPlanGroupDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<HousingPaymentPlanGroupDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HousingPaymentPlanGroupDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HousingPaymentPlanGroup/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getForUpdate(id: string | undefined): Observable<UpdateHousingPaymentPlanGroupDto> {
        let url_ = this.baseUrl + "/api/services/app/HousingPaymentPlanGroup/GetForUpdate?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateHousingPaymentPlanGroupDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateHousingPaymentPlanGroupDto>;
        }));
    }

    protected processGetForUpdate(response: HttpResponseBase): Observable<UpdateHousingPaymentPlanGroupDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateHousingPaymentPlanGroupDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param housingIds (optional) 
     * @param housingCategoryIds (optional) 
     * @param personIds (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(housingIds: string[] | undefined, housingCategoryIds: string[] | undefined, personIds: string[] | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<HousingPaymentPlanGroupDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/HousingPaymentPlanGroup/GetAll?";
        if (housingIds === null)
            throw new Error("The parameter 'housingIds' cannot be null.");
        else if (housingIds !== undefined)
            housingIds && housingIds.forEach(item => { url_ += "HousingIds=" + encodeURIComponent("" + item) + "&"; });
        if (housingCategoryIds === null)
            throw new Error("The parameter 'housingCategoryIds' cannot be null.");
        else if (housingCategoryIds !== undefined)
            housingCategoryIds && housingCategoryIds.forEach(item => { url_ += "HousingCategoryIds=" + encodeURIComponent("" + item) + "&"; });
        if (personIds === null)
            throw new Error("The parameter 'personIds' cannot be null.");
        else if (personIds !== undefined)
            personIds && personIds.forEach(item => { url_ += "PersonIds=" + encodeURIComponent("" + item) + "&"; });
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HousingPaymentPlanGroupDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HousingPaymentPlanGroupDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<HousingPaymentPlanGroupDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HousingPaymentPlanGroupDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getResidentOrOwnerLookUp(): Observable<LookUpDto[]> {
        let url_ = this.baseUrl + "/api/services/app/HousingPaymentPlanGroup/GetResidentOrOwnerLookUp";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetResidentOrOwnerLookUp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetResidentOrOwnerLookUp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LookUpDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LookUpDto[]>;
        }));
    }

    protected processGetResidentOrOwnerLookUp(response: HttpResponseBase): Observable<LookUpDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookUpDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<HousingPaymentPlanGroupDto> {
        let url_ = this.baseUrl + "/api/services/app/HousingPaymentPlanGroup/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HousingPaymentPlanGroupDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HousingPaymentPlanGroupDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<HousingPaymentPlanGroupDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HousingPaymentPlanGroupDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class InventoryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateInventoryDto | undefined): Observable<InventoryDto> {
        let url_ = this.baseUrl + "/api/services/app/Inventory/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InventoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InventoryDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<InventoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InventoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateInventoryDto | undefined): Observable<InventoryDto> {
        let url_ = this.baseUrl + "/api/services/app/Inventory/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InventoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InventoryDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<InventoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InventoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param inventoryTypeId (optional) 
     * @param quantity (optional) 
     * @param serialNumber (optional) 
     * @return Success
     */
    deleteFromInventoryPage(inventoryTypeId: string | undefined, quantity: number | undefined, serialNumber: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Inventory/DeleteFromInventoryPage?";
        if (inventoryTypeId === null)
            throw new Error("The parameter 'inventoryTypeId' cannot be null.");
        else if (inventoryTypeId !== undefined)
            url_ += "InventoryTypeId=" + encodeURIComponent("" + inventoryTypeId) + "&";
        if (quantity === null)
            throw new Error("The parameter 'quantity' cannot be null.");
        else if (quantity !== undefined)
            url_ += "Quantity=" + encodeURIComponent("" + quantity) + "&";
        if (serialNumber === null)
            throw new Error("The parameter 'serialNumber' cannot be null.");
        else if (serialNumber !== undefined)
            url_ += "SerialNumber=" + encodeURIComponent("" + serialNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteFromInventoryPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteFromInventoryPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteFromInventoryPage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Inventory/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteById(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Inventory/DeleteById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllInventories(sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<InventoryGetAllDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Inventory/GetAllInventories?";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllInventories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllInventories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InventoryGetAllDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InventoryGetAllDtoPagedResultDto>;
        }));
    }

    protected processGetAllInventories(response: HttpResponseBase): Observable<InventoryGetAllDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InventoryGetAllDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<InventoryDto> {
        let url_ = this.baseUrl + "/api/services/app/Inventory/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InventoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InventoryDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<InventoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InventoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<InventoryDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Inventory/GetAll?";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InventoryDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InventoryDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<InventoryDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InventoryDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class InventoryTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateInventoryTypeDto | undefined): Observable<InventoryTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/InventoryType/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InventoryTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InventoryTypeDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<InventoryTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InventoryTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateInventoryTypeDto | undefined): Observable<InventoryTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/InventoryType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InventoryTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InventoryTypeDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<InventoryTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InventoryTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/InventoryType/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<InventoryTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/InventoryType/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InventoryTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InventoryTypeDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<InventoryTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InventoryTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<InventoryTypeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/InventoryType/GetAll?";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InventoryTypeDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InventoryTypeDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<InventoryTypeDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InventoryTypeDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getLookUp(): Observable<LookUpDto[]> {
        let url_ = this.baseUrl + "/api/services/app/InventoryType/GetLookUp";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLookUp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLookUp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LookUpDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LookUpDto[]>;
        }));
    }

    protected processGetLookUp(response: HttpResponseBase): Observable<LookUpDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookUpDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PaymentAccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createBankAccount(body: CreateBankAccountDto | undefined): Observable<PaymentAccountDto> {
        let url_ = this.baseUrl + "/api/services/app/PaymentAccount/CreateBankAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateBankAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateBankAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentAccountDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentAccountDto>;
        }));
    }

    protected processCreateBankAccount(response: HttpResponseBase): Observable<PaymentAccountDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentAccountDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createCashAccount(body: CreateCashAccountDto | undefined): Observable<PaymentAccountDto> {
        let url_ = this.baseUrl + "/api/services/app/PaymentAccount/CreateCashAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCashAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCashAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentAccountDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentAccountDto>;
        }));
    }

    protected processCreateCashAccount(response: HttpResponseBase): Observable<PaymentAccountDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentAccountDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdatePaymentAccountDto | undefined): Observable<PaymentAccountDto> {
        let url_ = this.baseUrl + "/api/services/app/PaymentAccount/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentAccountDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentAccountDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<PaymentAccountDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentAccountDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PaymentAccount/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PaymentAccountDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PaymentAccount/GetAll?";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentAccountDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentAccountDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PaymentAccountDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentAccountDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getPaymentAccountLookUp(): Observable<LookUpDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PaymentAccount/GetPaymentAccountLookUp";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentAccountLookUp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentAccountLookUp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LookUpDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LookUpDto[]>;
        }));
    }

    protected processGetPaymentAccountLookUp(response: HttpResponseBase): Observable<LookUpDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookUpDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<PaymentAccountDto> {
        let url_ = this.baseUrl + "/api/services/app/PaymentAccount/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentAccountDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentAccountDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PaymentAccountDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentAccountDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PaymentCategoryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createIncome(body: CreateIncomePaymentCategoryDto | undefined): Observable<PaymentCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/PaymentCategory/CreateIncome";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateIncome(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateIncome(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentCategoryDto>;
        }));
    }

    protected processCreateIncome(response: HttpResponseBase): Observable<PaymentCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createExpense(body: CreateExpensePaymentCategoryDto | undefined): Observable<PaymentCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/PaymentCategory/CreateExpense";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateExpense(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateExpense(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentCategoryDto>;
        }));
    }

    protected processCreateExpense(response: HttpResponseBase): Observable<PaymentCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createTransfer(body: CreateTransferPaymentCategoryDto | undefined): Observable<PaymentCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/PaymentCategory/CreateTransfer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTransfer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTransfer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentCategoryDto>;
        }));
    }

    protected processCreateTransfer(response: HttpResponseBase): Observable<PaymentCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreatePaymentCategoryDto | undefined): Observable<PaymentCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/PaymentCategory/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentCategoryDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<PaymentCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdatePaymentCategoryDto | undefined): Observable<PaymentCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/PaymentCategory/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentCategoryDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<PaymentCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PaymentCategory/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param paymentCategoryName (optional) 
     * @param isPassive (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(paymentCategoryName: string | undefined, isPassive: boolean | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PaymentCategoryDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PaymentCategory/GetAll?";
        if (paymentCategoryName === null)
            throw new Error("The parameter 'paymentCategoryName' cannot be null.");
        else if (paymentCategoryName !== undefined)
            url_ += "PaymentCategoryName=" + encodeURIComponent("" + paymentCategoryName) + "&";
        if (isPassive === null)
            throw new Error("The parameter 'isPassive' cannot be null.");
        else if (isPassive !== undefined)
            url_ += "IsPassive=" + encodeURIComponent("" + isPassive) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentCategoryDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentCategoryDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PaymentCategoryDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentCategoryDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getPaymentCategoryForMenu(): Observable<PaymentCategoryDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PaymentCategory/GetPaymentCategoryForMenu";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentCategoryForMenu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentCategoryForMenu(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentCategoryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentCategoryDto[]>;
        }));
    }

    protected processGetPaymentCategoryForMenu(response: HttpResponseBase): Observable<PaymentCategoryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(PaymentCategoryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param onlyActives (optional) 
     * @return Success
     */
    getLookUp(onlyActives: boolean | undefined): Observable<LookUpDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PaymentCategory/GetLookUp?";
        if (onlyActives === null)
            throw new Error("The parameter 'onlyActives' cannot be null.");
        else if (onlyActives !== undefined)
            url_ += "onlyActives=" + encodeURIComponent("" + onlyActives) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLookUp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLookUp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LookUpDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LookUpDto[]>;
        }));
    }

    protected processGetLookUp(response: HttpResponseBase): Observable<LookUpDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookUpDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param onlyActives (optional) 
     * @param paymentCategoryType (optional) 
     * @return Success
     */
    getLookUpByPaymentCategoryType(onlyActives: boolean | undefined, paymentCategoryType: PaymentCategoryType | undefined): Observable<LookUpDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PaymentCategory/GetLookUpByPaymentCategoryType?";
        if (onlyActives === null)
            throw new Error("The parameter 'onlyActives' cannot be null.");
        else if (onlyActives !== undefined)
            url_ += "onlyActives=" + encodeURIComponent("" + onlyActives) + "&";
        if (paymentCategoryType === null)
            throw new Error("The parameter 'paymentCategoryType' cannot be null.");
        else if (paymentCategoryType !== undefined)
            url_ += "paymentCategoryType=" + encodeURIComponent("" + paymentCategoryType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLookUpByPaymentCategoryType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLookUpByPaymentCategoryType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LookUpDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LookUpDto[]>;
        }));
    }

    protected processGetLookUpByPaymentCategoryType(response: HttpResponseBase): Observable<LookUpDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookUpDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getHousingDueLookUp(): Observable<LookUpDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PaymentCategory/GetHousingDueLookUp";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHousingDueLookUp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHousingDueLookUp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LookUpDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LookUpDto[]>;
        }));
    }

    protected processGetHousingDueLookUp(response: HttpResponseBase): Observable<LookUpDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookUpDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param housingId (optional) 
     * @return Success
     */
    getLookUpByHousingId(housingId: string | undefined): Observable<LookUpDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PaymentCategory/GetLookUpByHousingId?";
        if (housingId === null)
            throw new Error("The parameter 'housingId' cannot be null.");
        else if (housingId !== undefined)
            url_ += "housingId=" + encodeURIComponent("" + housingId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLookUpByHousingId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLookUpByHousingId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LookUpDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LookUpDto[]>;
        }));
    }

    protected processGetLookUpByHousingId(response: HttpResponseBase): Observable<LookUpDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookUpDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getPaymentCategoryForTransferLookUp(): Observable<LookUpDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PaymentCategory/GetPaymentCategoryForTransferLookUp";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentCategoryForTransferLookUp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentCategoryForTransferLookUp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LookUpDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LookUpDto[]>;
        }));
    }

    protected processGetPaymentCategoryForTransferLookUp(response: HttpResponseBase): Observable<LookUpDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookUpDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param request (optional) 
     * @return Success
     */
    getPaymentCategoryFromAutoCompleteFilter(request: string | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/PaymentCategory/GetPaymentCategoryFromAutoCompleteFilter?";
        if (request === null)
            throw new Error("The parameter 'request' cannot be null.");
        else if (request !== undefined)
            url_ += "request=" + encodeURIComponent("" + request) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentCategoryFromAutoCompleteFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentCategoryFromAutoCompleteFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetPaymentCategoryFromAutoCompleteFilter(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<PaymentCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/PaymentCategory/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentCategoryDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PaymentCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PeriodServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createForSite(body: CreatePeriodForSiteDto | undefined): Observable<PeriodDto> {
        let url_ = this.baseUrl + "/api/services/app/Period/CreateForSite";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateForSite(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateForSite(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PeriodDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PeriodDto>;
        }));
    }

    protected processCreateForSite(response: HttpResponseBase): Observable<PeriodDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PeriodDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createForBlock(body: CreatePeriodForBlockDto | undefined): Observable<PeriodDto> {
        let url_ = this.baseUrl + "/api/services/app/Period/CreateForBlock";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateForBlock(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateForBlock(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PeriodDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PeriodDto>;
        }));
    }

    protected processCreateForBlock(response: HttpResponseBase): Observable<PeriodDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PeriodDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreatePeriodForSiteDto | undefined): Observable<PeriodDto> {
        let url_ = this.baseUrl + "/api/services/app/Period/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PeriodDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PeriodDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<PeriodDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PeriodDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdatePeriodDto | undefined): Observable<PeriodDto> {
        let url_ = this.baseUrl + "/api/services/app/Period/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PeriodDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PeriodDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<PeriodDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PeriodDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Period/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param name (optional) 
     * @param siteOrBlock (optional) 
     * @param blockId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(name: string | undefined, siteOrBlock: SiteOrBlock | undefined, blockId: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PeriodDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Period/GetAll?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (siteOrBlock === null)
            throw new Error("The parameter 'siteOrBlock' cannot be null.");
        else if (siteOrBlock !== undefined)
            url_ += "SiteOrBlock=" + encodeURIComponent("" + siteOrBlock) + "&";
        if (blockId === null)
            throw new Error("The parameter 'blockId' cannot be null.");
        else if (blockId !== undefined)
            url_ += "BlockId=" + encodeURIComponent("" + blockId) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PeriodDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PeriodDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PeriodDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PeriodDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getPeriodLookUp(): Observable<LookUpDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Period/GetPeriodLookUp";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPeriodLookUp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPeriodLookUp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LookUpDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LookUpDto[]>;
        }));
    }

    protected processGetPeriodLookUp(response: HttpResponseBase): Observable<LookUpDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookUpDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<PeriodDto> {
        let url_ = this.baseUrl + "/api/services/app/Period/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PeriodDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PeriodDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PeriodDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PeriodDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PersonServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreatePersonDto | undefined): Observable<PersonDto> {
        let url_ = this.baseUrl + "/api/services/app/Person/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PersonDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PersonDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<PersonDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PersonDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdatePersonDto | undefined): Observable<PersonDto> {
        let url_ = this.baseUrl + "/api/services/app/Person/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PersonDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PersonDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<PersonDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PersonDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Person/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param name (optional) 
     * @param phoneNumber (optional) 
     * @param housingIds (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(name: string | undefined, phoneNumber: string | undefined, housingIds: string[] | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PersonDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Person/GetAll?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (phoneNumber === null)
            throw new Error("The parameter 'phoneNumber' cannot be null.");
        else if (phoneNumber !== undefined)
            url_ += "PhoneNumber=" + encodeURIComponent("" + phoneNumber) + "&";
        if (housingIds === null)
            throw new Error("The parameter 'housingIds' cannot be null.");
        else if (housingIds !== undefined)
            housingIds && housingIds.forEach(item => { url_ += "HousingIds=" + encodeURIComponent("" + item) + "&"; });
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PersonDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PersonDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PersonDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PersonDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getPersonLookUp(): Observable<LookUpDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Person/GetPersonLookUp";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPersonLookUp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPersonLookUp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LookUpDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LookUpDto[]>;
        }));
    }

    protected processGetPersonLookUp(response: HttpResponseBase): Observable<LookUpDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookUpDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param paymentCategoryId (optional) 
     * @return Success
     */
    getPersonLookUpForHousingDue(paymentCategoryId: string | undefined): Observable<LookUpDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Person/GetPersonLookUpForHousingDue?";
        if (paymentCategoryId === null)
            throw new Error("The parameter 'paymentCategoryId' cannot be null.");
        else if (paymentCategoryId !== undefined)
            url_ += "PaymentCategoryId=" + encodeURIComponent("" + paymentCategoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPersonLookUpForHousingDue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPersonLookUpForHousingDue(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LookUpDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LookUpDto[]>;
        }));
    }

    protected processGetPersonLookUpForHousingDue(response: HttpResponseBase): Observable<LookUpDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LookUpDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param request (optional) 
     * @return Success
     */
    getPeopleFromAutoCompleteFilter(request: string | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/Person/GetPeopleFromAutoCompleteFilter?";
        if (request === null)
            throw new Error("The parameter 'request' cannot be null.");
        else if (request !== undefined)
            url_ += "request=" + encodeURIComponent("" + request) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPeopleFromAutoCompleteFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPeopleFromAutoCompleteFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetPeopleFromAutoCompleteFilter(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<PersonDto> {
        let url_ = this.baseUrl + "/api/services/app/Person/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PersonDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PersonDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PersonDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PersonDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ReportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getDashboardData(): Observable<DashboardDto> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetDashboardData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashboardData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashboardDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashboardDto>;
        }));
    }

    protected processGetDashboardData(response: HttpResponseBase): Observable<DashboardDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DashboardDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getFinancialStatement(): Observable<FinancialStatementDto> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetFinancialStatement";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFinancialStatement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFinancialStatement(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FinancialStatementDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FinancialStatementDto>;
        }));
    }

    protected processGetFinancialStatement(response: HttpResponseBase): Observable<FinancialStatementDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FinancialStatementDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateRoleDto | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param permission (optional) 
     * @return Success
     */
    getRoles(permission: string | undefined): Observable<RoleListDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoles?";
        if (permission === null)
            throw new Error("The parameter 'permission' cannot be null.");
        else if (permission !== undefined)
            url_ += "Permission=" + encodeURIComponent("" + permission) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleListDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleListDtoListResultDto>;
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<RoleListDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleListDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: RoleDto | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllPermissions(): Observable<PermissionDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionDtoListResultDto>;
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<PermissionDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRoleForEdit(id: number | undefined): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRoleForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRoleForEditOutput>;
        }));
    }

    protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRoleForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<RoleDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<RoleDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCurrentLoginInformationsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCurrentLoginInformationsOutput>;
        }));
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCurrentLoginInformationsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateTenantDto | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, isActive: boolean | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<TenantDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TenantDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: TenantDto | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticate(body: AuthenticateModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticateResultModel>;
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExternalAuthenticationProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalAuthenticationProviders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExternalLoginProviderInfoModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExternalLoginProviderInfoModel[]>;
        }));
    }

    protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    externalAuthenticate(body: ExternalAuthenticateModel | undefined): Observable<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExternalAuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExternalAuthenticateResultModel>;
        }));
    }

    protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UploadServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param file (optional) 
     * @return Success
     */
    uploadFile(file: FileParameter | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Upload/UploadFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processUploadFile(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateUserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    activate(body: Int64EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Activate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processActivate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deActivate(body: Int64EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/DeActivate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeActivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeActivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeActivate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getRoles(): Observable<RoleDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDtoListResultDto>;
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<RoleDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeLanguage(body: ChangeUserLanguageDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: ResetPasswordDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, isActive: boolean | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<UserDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<UserDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class AccountBookDto implements IAccountBookDto {
    id: string;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    processDateTime: moment.Moment;
    accountBookType: AccountBookType;
    paymentCategoryId: string;
    housingId: string | undefined;
    fromPaymentAccountId: string | undefined;
    toPaymentAccountId: string | undefined;
    amount: number;
    description: string | undefined;
    documentDateTime: moment.Moment | undefined;
    documentNumber: string | undefined;
    fromPaymentAccountCurrentBalance: number | undefined;
    toPaymentAccountCurrentBalance: number | undefined;
    nettingHousing: boolean;
    housingIdForNetting: string | undefined;
    sameDayIndex: number;
    accountBookFiles: AccountBookFileDto[] | undefined;
    inventories: InventoryDto[] | undefined;

    constructor(data?: IAccountBookDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.processDateTime = _data["processDateTime"] ? moment(_data["processDateTime"].toString()) : <any>undefined;
            this.accountBookType = _data["accountBookType"];
            this.paymentCategoryId = _data["paymentCategoryId"];
            this.housingId = _data["housingId"];
            this.fromPaymentAccountId = _data["fromPaymentAccountId"];
            this.toPaymentAccountId = _data["toPaymentAccountId"];
            this.amount = _data["amount"];
            this.description = _data["description"];
            this.documentDateTime = _data["documentDateTime"] ? moment(_data["documentDateTime"].toString()) : <any>undefined;
            this.documentNumber = _data["documentNumber"];
            this.fromPaymentAccountCurrentBalance = _data["fromPaymentAccountCurrentBalance"];
            this.toPaymentAccountCurrentBalance = _data["toPaymentAccountCurrentBalance"];
            this.nettingHousing = _data["nettingHousing"];
            this.housingIdForNetting = _data["housingIdForNetting"];
            this.sameDayIndex = _data["sameDayIndex"];
            if (Array.isArray(_data["accountBookFiles"])) {
                this.accountBookFiles = [] as any;
                for (let item of _data["accountBookFiles"])
                    this.accountBookFiles.push(AccountBookFileDto.fromJS(item));
            }
            if (Array.isArray(_data["inventories"])) {
                this.inventories = [] as any;
                for (let item of _data["inventories"])
                    this.inventories.push(InventoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AccountBookDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountBookDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["processDateTime"] = this.processDateTime ? this.processDateTime.toISOString() : <any>undefined;
        data["accountBookType"] = this.accountBookType;
        data["paymentCategoryId"] = this.paymentCategoryId;
        data["housingId"] = this.housingId;
        data["fromPaymentAccountId"] = this.fromPaymentAccountId;
        data["toPaymentAccountId"] = this.toPaymentAccountId;
        data["amount"] = this.amount;
        data["description"] = this.description;
        data["documentDateTime"] = this.documentDateTime ? this.documentDateTime.toISOString() : <any>undefined;
        data["documentNumber"] = this.documentNumber;
        data["fromPaymentAccountCurrentBalance"] = this.fromPaymentAccountCurrentBalance;
        data["toPaymentAccountCurrentBalance"] = this.toPaymentAccountCurrentBalance;
        data["nettingHousing"] = this.nettingHousing;
        data["housingIdForNetting"] = this.housingIdForNetting;
        data["sameDayIndex"] = this.sameDayIndex;
        if (Array.isArray(this.accountBookFiles)) {
            data["accountBookFiles"] = [];
            for (let item of this.accountBookFiles)
                data["accountBookFiles"].push(item.toJSON());
        }
        if (Array.isArray(this.inventories)) {
            data["inventories"] = [];
            for (let item of this.inventories)
                data["inventories"].push(item.toJSON());
        }
        return data;
    }

    clone(): AccountBookDto {
        const json = this.toJSON();
        let result = new AccountBookDto();
        result.init(json);
        return result;
    }
}

export interface IAccountBookDto {
    id: string;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    processDateTime: moment.Moment;
    accountBookType: AccountBookType;
    paymentCategoryId: string;
    housingId: string | undefined;
    fromPaymentAccountId: string | undefined;
    toPaymentAccountId: string | undefined;
    amount: number;
    description: string | undefined;
    documentDateTime: moment.Moment | undefined;
    documentNumber: string | undefined;
    fromPaymentAccountCurrentBalance: number | undefined;
    toPaymentAccountCurrentBalance: number | undefined;
    nettingHousing: boolean;
    housingIdForNetting: string | undefined;
    sameDayIndex: number;
    accountBookFiles: AccountBookFileDto[] | undefined;
    inventories: InventoryDto[] | undefined;
}

export class AccountBookDtoPagedResultDto implements IAccountBookDtoPagedResultDto {
    items: AccountBookDto[] | undefined;
    totalCount: number;

    constructor(data?: IAccountBookDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(AccountBookDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AccountBookDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountBookDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): AccountBookDtoPagedResultDto {
        const json = this.toJSON();
        let result = new AccountBookDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IAccountBookDtoPagedResultDto {
    items: AccountBookDto[] | undefined;
    totalCount: number;
}

export class AccountBookFileDto implements IAccountBookFileDto {
    id: string;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    fileUrl: string | undefined;
    accountBookId: string;

    constructor(data?: IAccountBookFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.fileUrl = _data["fileUrl"];
            this.accountBookId = _data["accountBookId"];
        }
    }

    static fromJS(data: any): AccountBookFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountBookFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["fileUrl"] = this.fileUrl;
        data["accountBookId"] = this.accountBookId;
        return data;
    }

    clone(): AccountBookFileDto {
        const json = this.toJSON();
        let result = new AccountBookFileDto();
        result.init(json);
        return result;
    }
}

export interface IAccountBookFileDto {
    id: string;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    fileUrl: string | undefined;
    accountBookId: string;
}

export class AccountBookGetAllExportOutput implements IAccountBookGetAllExportOutput {
    processDateTime: string | undefined;
    paymentCategoryName: string | undefined;
    housingName: string | undefined;
    amount: number;
    fromPaymentAccountName: string | undefined;
    toPaymentAccountName: string | undefined;
    fromPaymentAccountBalance: number | undefined;
    toPaymentAccountBalance: number | undefined;

    constructor(data?: IAccountBookGetAllExportOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.processDateTime = _data["processDateTime"];
            this.paymentCategoryName = _data["paymentCategoryName"];
            this.housingName = _data["housingName"];
            this.amount = _data["amount"];
            this.fromPaymentAccountName = _data["fromPaymentAccountName"];
            this.toPaymentAccountName = _data["toPaymentAccountName"];
            this.fromPaymentAccountBalance = _data["fromPaymentAccountBalance"];
            this.toPaymentAccountBalance = _data["toPaymentAccountBalance"];
        }
    }

    static fromJS(data: any): AccountBookGetAllExportOutput {
        data = typeof data === 'object' ? data : {};
        let result = new AccountBookGetAllExportOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["processDateTime"] = this.processDateTime;
        data["paymentCategoryName"] = this.paymentCategoryName;
        data["housingName"] = this.housingName;
        data["amount"] = this.amount;
        data["fromPaymentAccountName"] = this.fromPaymentAccountName;
        data["toPaymentAccountName"] = this.toPaymentAccountName;
        data["fromPaymentAccountBalance"] = this.fromPaymentAccountBalance;
        data["toPaymentAccountBalance"] = this.toPaymentAccountBalance;
        return data;
    }

    clone(): AccountBookGetAllExportOutput {
        const json = this.toJSON();
        let result = new AccountBookGetAllExportOutput();
        result.init(json);
        return result;
    }
}

export interface IAccountBookGetAllExportOutput {
    processDateTime: string | undefined;
    paymentCategoryName: string | undefined;
    housingName: string | undefined;
    amount: number;
    fromPaymentAccountName: string | undefined;
    toPaymentAccountName: string | undefined;
    fromPaymentAccountBalance: number | undefined;
    toPaymentAccountBalance: number | undefined;
}

export class AccountBookGetAllOutput implements IAccountBookGetAllOutput {
    id: string;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    processDateTime: moment.Moment;
    accountBookType: AccountBookType;
    paymentCategoryName: string | undefined;
    housingName: string | undefined;
    amount: number;
    fromPaymentAccountName: string | undefined;
    toPaymentAccountName: string | undefined;
    fromPaymentAccountBalance: number | undefined;
    toPaymentAccountBalance: number | undefined;
    nettingHousing: boolean;
    nettingHousingBlockApartment: string | undefined;
    sameDayIndex: number;
    accountBookFiles: string[] | undefined;

    constructor(data?: IAccountBookGetAllOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.processDateTime = _data["processDateTime"] ? moment(_data["processDateTime"].toString()) : <any>undefined;
            this.accountBookType = _data["accountBookType"];
            this.paymentCategoryName = _data["paymentCategoryName"];
            this.housingName = _data["housingName"];
            this.amount = _data["amount"];
            this.fromPaymentAccountName = _data["fromPaymentAccountName"];
            this.toPaymentAccountName = _data["toPaymentAccountName"];
            this.fromPaymentAccountBalance = _data["fromPaymentAccountBalance"];
            this.toPaymentAccountBalance = _data["toPaymentAccountBalance"];
            this.nettingHousing = _data["nettingHousing"];
            this.nettingHousingBlockApartment = _data["nettingHousingBlockApartment"];
            this.sameDayIndex = _data["sameDayIndex"];
            if (Array.isArray(_data["accountBookFiles"])) {
                this.accountBookFiles = [] as any;
                for (let item of _data["accountBookFiles"])
                    this.accountBookFiles.push(item);
            }
        }
    }

    static fromJS(data: any): AccountBookGetAllOutput {
        data = typeof data === 'object' ? data : {};
        let result = new AccountBookGetAllOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["processDateTime"] = this.processDateTime ? this.processDateTime.toISOString() : <any>undefined;
        data["accountBookType"] = this.accountBookType;
        data["paymentCategoryName"] = this.paymentCategoryName;
        data["housingName"] = this.housingName;
        data["amount"] = this.amount;
        data["fromPaymentAccountName"] = this.fromPaymentAccountName;
        data["toPaymentAccountName"] = this.toPaymentAccountName;
        data["fromPaymentAccountBalance"] = this.fromPaymentAccountBalance;
        data["toPaymentAccountBalance"] = this.toPaymentAccountBalance;
        data["nettingHousing"] = this.nettingHousing;
        data["nettingHousingBlockApartment"] = this.nettingHousingBlockApartment;
        data["sameDayIndex"] = this.sameDayIndex;
        if (Array.isArray(this.accountBookFiles)) {
            data["accountBookFiles"] = [];
            for (let item of this.accountBookFiles)
                data["accountBookFiles"].push(item);
        }
        return data;
    }

    clone(): AccountBookGetAllOutput {
        const json = this.toJSON();
        let result = new AccountBookGetAllOutput();
        result.init(json);
        return result;
    }
}

export interface IAccountBookGetAllOutput {
    id: string;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    processDateTime: moment.Moment;
    accountBookType: AccountBookType;
    paymentCategoryName: string | undefined;
    housingName: string | undefined;
    amount: number;
    fromPaymentAccountName: string | undefined;
    toPaymentAccountName: string | undefined;
    fromPaymentAccountBalance: number | undefined;
    toPaymentAccountBalance: number | undefined;
    nettingHousing: boolean;
    nettingHousingBlockApartment: string | undefined;
    sameDayIndex: number;
    accountBookFiles: string[] | undefined;
}

export enum AccountBookType {
    HousingDue = 1,
    OtherPaymentWithNettingForHousingDue = 2,
    FirstTransferForPaymentAccount = 3,
    Other = 4,
    TransferForPaymentAccountToNextPeriod = 5,
    TransferForPaymentAccountFromPreviousPeriod = 6,
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment;
    features: { [key: string]: boolean; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
            this.releaseDate = _data["releaseDate"] ? moment(_data["releaseDate"].toString()) : <any>undefined;
            if (_data["features"]) {
                this.features = {} as any;
                for (let key in _data["features"]) {
                    if (_data["features"].hasOwnProperty(key))
                        (<any>this.features)[key] = _data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    (<any>data["features"])[key] = (<any>this.features)[key];
            }
        }
        return data;
    }

    clone(): ApplicationInfoDto {
        const json = this.toJSON();
        let result = new ApplicationInfoDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment;
    features: { [key: string]: boolean; } | undefined;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userNameOrEmailAddress = _data["userNameOrEmailAddress"];
            this.password = _data["password"];
            this.rememberClient = _data["rememberClient"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["rememberClient"] = this.rememberClient;
        return data;
    }

    clone(): AuthenticateModel {
        const json = this.toJSON();
        let result = new AuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["userId"] = this.userId;
        return data;
    }

    clone(): AuthenticateResultModel {
        const json = this.toJSON();
        let result = new AuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;
}

export class Block implements IBlock {
    id: string;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    tenantId: number;
    readonly blockName: string;

    constructor(data?: IBlock) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
            (<any>this).blockName = _data["blockName"];
        }
    }

    static fromJS(data: any): Block {
        data = typeof data === 'object' ? data : {};
        let result = new Block();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["blockName"] = this.blockName;
        return data;
    }

    clone(): Block {
        const json = this.toJSON();
        let result = new Block();
        result.init(json);
        return result;
    }
}

export interface IBlock {
    id: string;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    tenantId: number;
    blockName: string;
}

export class BlockDto implements IBlockDto {
    id: string;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    blockName: string | undefined;

    constructor(data?: IBlockDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.blockName = _data["blockName"];
        }
    }

    static fromJS(data: any): BlockDto {
        data = typeof data === 'object' ? data : {};
        let result = new BlockDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["blockName"] = this.blockName;
        return data;
    }

    clone(): BlockDto {
        const json = this.toJSON();
        let result = new BlockDto();
        result.init(json);
        return result;
    }
}

export interface IBlockDto {
    id: string;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    blockName: string | undefined;
}

export class BlockDtoPagedResultDto implements IBlockDtoPagedResultDto {
    items: BlockDto[] | undefined;
    totalCount: number;

    constructor(data?: IBlockDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(BlockDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): BlockDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new BlockDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): BlockDtoPagedResultDto {
        const json = this.toJSON();
        let result = new BlockDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IBlockDtoPagedResultDto {
    items: BlockDto[] | undefined;
    totalCount: number;
}

export class ChangePasswordDto implements IChangePasswordDto {
    currentPassword: string;
    newPassword: string;

    constructor(data?: IChangePasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data;
    }

    clone(): ChangePasswordDto {
        const json = this.toJSON();
        let result = new ChangePasswordDto();
        result.init(json);
        return result;
    }
}

export interface IChangePasswordDto {
    currentPassword: string;
    newPassword: string;
}

export class ChangeUiThemeInput implements IChangeUiThemeInput {
    theme: string;

    constructor(data?: IChangeUiThemeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.theme = _data["theme"];
        }
    }

    static fromJS(data: any): ChangeUiThemeInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUiThemeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        return data;
    }

    clone(): ChangeUiThemeInput {
        const json = this.toJSON();
        let result = new ChangeUiThemeInput();
        result.init(json);
        return result;
    }
}

export interface IChangeUiThemeInput {
    theme: string;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName: string;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.languageName = _data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data;
    }

    clone(): ChangeUserLanguageDto {
        const json = this.toJSON();
        let result = new ChangeUserLanguageDto();
        result.init(json);
        return result;
    }
}

export interface IChangeUserLanguageDto {
    languageName: string;
}

export class CreateAccountBookDto implements ICreateAccountBookDto {
    processDateString: string | undefined;
    paymentCategoryType: PaymentCategoryType;
    isHousingDue: boolean;
    housingId: string;
    paymentCategoryId: string;
    fromPaymentAccountId: string | undefined;
    toPaymentAccountId: string | undefined;
    amount: number;
    description: string | undefined;
    documentDateTimeString: string | undefined;
    documentNumber: string | undefined;
    accountBookFileUrls: string[] | undefined;
    nettingFromHousingDue: boolean;
    housingIdForNetting: string | undefined;
    paymentCategoryIdForNetting: string | undefined;
    inventories: CreateInventoryDto[] | undefined;

    constructor(data?: ICreateAccountBookDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.processDateString = _data["processDateString"];
            this.paymentCategoryType = _data["paymentCategoryType"];
            this.isHousingDue = _data["isHousingDue"];
            this.housingId = _data["housingId"];
            this.paymentCategoryId = _data["paymentCategoryId"];
            this.fromPaymentAccountId = _data["fromPaymentAccountId"];
            this.toPaymentAccountId = _data["toPaymentAccountId"];
            this.amount = _data["amount"];
            this.description = _data["description"];
            this.documentDateTimeString = _data["documentDateTimeString"];
            this.documentNumber = _data["documentNumber"];
            if (Array.isArray(_data["accountBookFileUrls"])) {
                this.accountBookFileUrls = [] as any;
                for (let item of _data["accountBookFileUrls"])
                    this.accountBookFileUrls.push(item);
            }
            this.nettingFromHousingDue = _data["nettingFromHousingDue"];
            this.housingIdForNetting = _data["housingIdForNetting"];
            this.paymentCategoryIdForNetting = _data["paymentCategoryIdForNetting"];
            if (Array.isArray(_data["inventories"])) {
                this.inventories = [] as any;
                for (let item of _data["inventories"])
                    this.inventories.push(CreateInventoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateAccountBookDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAccountBookDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["processDateString"] = this.processDateString;
        data["paymentCategoryType"] = this.paymentCategoryType;
        data["isHousingDue"] = this.isHousingDue;
        data["housingId"] = this.housingId;
        data["paymentCategoryId"] = this.paymentCategoryId;
        data["fromPaymentAccountId"] = this.fromPaymentAccountId;
        data["toPaymentAccountId"] = this.toPaymentAccountId;
        data["amount"] = this.amount;
        data["description"] = this.description;
        data["documentDateTimeString"] = this.documentDateTimeString;
        data["documentNumber"] = this.documentNumber;
        if (Array.isArray(this.accountBookFileUrls)) {
            data["accountBookFileUrls"] = [];
            for (let item of this.accountBookFileUrls)
                data["accountBookFileUrls"].push(item);
        }
        data["nettingFromHousingDue"] = this.nettingFromHousingDue;
        data["housingIdForNetting"] = this.housingIdForNetting;
        data["paymentCategoryIdForNetting"] = this.paymentCategoryIdForNetting;
        if (Array.isArray(this.inventories)) {
            data["inventories"] = [];
            for (let item of this.inventories)
                data["inventories"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateAccountBookDto {
        const json = this.toJSON();
        let result = new CreateAccountBookDto();
        result.init(json);
        return result;
    }
}

export interface ICreateAccountBookDto {
    processDateString: string | undefined;
    paymentCategoryType: PaymentCategoryType;
    isHousingDue: boolean;
    housingId: string;
    paymentCategoryId: string;
    fromPaymentAccountId: string | undefined;
    toPaymentAccountId: string | undefined;
    amount: number;
    description: string | undefined;
    documentDateTimeString: string | undefined;
    documentNumber: string | undefined;
    accountBookFileUrls: string[] | undefined;
    nettingFromHousingDue: boolean;
    housingIdForNetting: string | undefined;
    paymentCategoryIdForNetting: string | undefined;
    inventories: CreateInventoryDto[] | undefined;
}

export class CreateBankAccountDto implements ICreateBankAccountDto {
    accountName: string | undefined;
    description: string | undefined;
    personId: string | undefined;
    employeeId: string | undefined;
    iban: string | undefined;
    tenantIsOwner: boolean;
    firstTransferDateTimeString: string | undefined;
    transferAmount: number | undefined;
    allowNegativeBalance: boolean;

    constructor(data?: ICreateBankAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountName = _data["accountName"];
            this.description = _data["description"];
            this.personId = _data["personId"];
            this.employeeId = _data["employeeId"];
            this.iban = _data["iban"];
            this.tenantIsOwner = _data["tenantIsOwner"];
            this.firstTransferDateTimeString = _data["firstTransferDateTimeString"];
            this.transferAmount = _data["transferAmount"];
            this.allowNegativeBalance = _data["allowNegativeBalance"];
        }
    }

    static fromJS(data: any): CreateBankAccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBankAccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountName"] = this.accountName;
        data["description"] = this.description;
        data["personId"] = this.personId;
        data["employeeId"] = this.employeeId;
        data["iban"] = this.iban;
        data["tenantIsOwner"] = this.tenantIsOwner;
        data["firstTransferDateTimeString"] = this.firstTransferDateTimeString;
        data["transferAmount"] = this.transferAmount;
        data["allowNegativeBalance"] = this.allowNegativeBalance;
        return data;
    }

    clone(): CreateBankAccountDto {
        const json = this.toJSON();
        let result = new CreateBankAccountDto();
        result.init(json);
        return result;
    }
}

export interface ICreateBankAccountDto {
    accountName: string | undefined;
    description: string | undefined;
    personId: string | undefined;
    employeeId: string | undefined;
    iban: string | undefined;
    tenantIsOwner: boolean;
    firstTransferDateTimeString: string | undefined;
    transferAmount: number | undefined;
    allowNegativeBalance: boolean;
}

export class CreateBlockDto implements ICreateBlockDto {
    blockName: string | undefined;

    constructor(data?: ICreateBlockDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.blockName = _data["blockName"];
        }
    }

    static fromJS(data: any): CreateBlockDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBlockDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["blockName"] = this.blockName;
        return data;
    }

    clone(): CreateBlockDto {
        const json = this.toJSON();
        let result = new CreateBlockDto();
        result.init(json);
        return result;
    }
}

export interface ICreateBlockDto {
    blockName: string | undefined;
}

export class CreateCashAccountDto implements ICreateCashAccountDto {
    accountName: string | undefined;
    description: string | undefined;
    personId: string | undefined;
    employeeId: string | undefined;
    tenantIsOwner: boolean;
    firstTransferDateTimeString: string | undefined;
    transferAmount: number | undefined;
    allowNegativeBalance: boolean;

    constructor(data?: ICreateCashAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountName = _data["accountName"];
            this.description = _data["description"];
            this.personId = _data["personId"];
            this.employeeId = _data["employeeId"];
            this.tenantIsOwner = _data["tenantIsOwner"];
            this.firstTransferDateTimeString = _data["firstTransferDateTimeString"];
            this.transferAmount = _data["transferAmount"];
            this.allowNegativeBalance = _data["allowNegativeBalance"];
        }
    }

    static fromJS(data: any): CreateCashAccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCashAccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountName"] = this.accountName;
        data["description"] = this.description;
        data["personId"] = this.personId;
        data["employeeId"] = this.employeeId;
        data["tenantIsOwner"] = this.tenantIsOwner;
        data["firstTransferDateTimeString"] = this.firstTransferDateTimeString;
        data["transferAmount"] = this.transferAmount;
        data["allowNegativeBalance"] = this.allowNegativeBalance;
        return data;
    }

    clone(): CreateCashAccountDto {
        const json = this.toJSON();
        let result = new CreateCashAccountDto();
        result.init(json);
        return result;
    }
}

export interface ICreateCashAccountDto {
    accountName: string | undefined;
    description: string | undefined;
    personId: string | undefined;
    employeeId: string | undefined;
    tenantIsOwner: boolean;
    firstTransferDateTimeString: string | undefined;
    transferAmount: number | undefined;
    allowNegativeBalance: boolean;
}

export class CreateCreditHousingPaymentPlanDto implements ICreateCreditHousingPaymentPlanDto {
    housingId: string;
    readonly paymentCategoryId: string;
    housingPaymentPlanDateString: string | undefined;
    amount: number;
    description: string | undefined;
    accountBookId: string;

    constructor(data?: ICreateCreditHousingPaymentPlanDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.housingId = _data["housingId"];
            (<any>this).paymentCategoryId = _data["paymentCategoryId"];
            this.housingPaymentPlanDateString = _data["housingPaymentPlanDateString"];
            this.amount = _data["amount"];
            this.description = _data["description"];
            this.accountBookId = _data["accountBookId"];
        }
    }

    static fromJS(data: any): CreateCreditHousingPaymentPlanDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCreditHousingPaymentPlanDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["housingId"] = this.housingId;
        data["paymentCategoryId"] = this.paymentCategoryId;
        data["housingPaymentPlanDateString"] = this.housingPaymentPlanDateString;
        data["amount"] = this.amount;
        data["description"] = this.description;
        data["accountBookId"] = this.accountBookId;
        return data;
    }

    clone(): CreateCreditHousingPaymentPlanDto {
        const json = this.toJSON();
        let result = new CreateCreditHousingPaymentPlanDto();
        result.init(json);
        return result;
    }
}

export interface ICreateCreditHousingPaymentPlanDto {
    housingId: string;
    paymentCategoryId: string;
    housingPaymentPlanDateString: string | undefined;
    amount: number;
    description: string | undefined;
    accountBookId: string;
}

export class CreateDebtHousingPaymentPlanDto implements ICreateDebtHousingPaymentPlanDto {
    housingId: string;
    readonly paymentCategoryId: string;
    housingPaymentPlanDateString: string | undefined;
    amount: number;
    description: string | undefined;

    constructor(data?: ICreateDebtHousingPaymentPlanDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.housingId = _data["housingId"];
            (<any>this).paymentCategoryId = _data["paymentCategoryId"];
            this.housingPaymentPlanDateString = _data["housingPaymentPlanDateString"];
            this.amount = _data["amount"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateDebtHousingPaymentPlanDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDebtHousingPaymentPlanDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["housingId"] = this.housingId;
        data["paymentCategoryId"] = this.paymentCategoryId;
        data["housingPaymentPlanDateString"] = this.housingPaymentPlanDateString;
        data["amount"] = this.amount;
        data["description"] = this.description;
        return data;
    }

    clone(): CreateDebtHousingPaymentPlanDto {
        const json = this.toJSON();
        let result = new CreateDebtHousingPaymentPlanDto();
        result.init(json);
        return result;
    }
}

export interface ICreateDebtHousingPaymentPlanDto {
    housingId: string;
    paymentCategoryId: string;
    housingPaymentPlanDateString: string | undefined;
    amount: number;
    description: string | undefined;
}

export class CreateEmployeeDto implements ICreateEmployeeDto {
    firstName: string | undefined;
    lastName: string | undefined;
    phone1: string | undefined;
    phone2: string | undefined;

    constructor(data?: ICreateEmployeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.phone1 = _data["phone1"];
            this.phone2 = _data["phone2"];
        }
    }

    static fromJS(data: any): CreateEmployeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEmployeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["phone1"] = this.phone1;
        data["phone2"] = this.phone2;
        return data;
    }

    clone(): CreateEmployeeDto {
        const json = this.toJSON();
        let result = new CreateEmployeeDto();
        result.init(json);
        return result;
    }
}

export interface ICreateEmployeeDto {
    firstName: string | undefined;
    lastName: string | undefined;
    phone1: string | undefined;
    phone2: string | undefined;
}

export class CreateExpensePaymentCategoryDto implements ICreateExpensePaymentCategoryDto {
    paymentCategoryName: string | undefined;
    isValidForAllPeriods: boolean;
    defaultFromPaymentAccountId: string;

    constructor(data?: ICreateExpensePaymentCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentCategoryName = _data["paymentCategoryName"];
            this.isValidForAllPeriods = _data["isValidForAllPeriods"];
            this.defaultFromPaymentAccountId = _data["defaultFromPaymentAccountId"];
        }
    }

    static fromJS(data: any): CreateExpensePaymentCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateExpensePaymentCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentCategoryName"] = this.paymentCategoryName;
        data["isValidForAllPeriods"] = this.isValidForAllPeriods;
        data["defaultFromPaymentAccountId"] = this.defaultFromPaymentAccountId;
        return data;
    }

    clone(): CreateExpensePaymentCategoryDto {
        const json = this.toJSON();
        let result = new CreateExpensePaymentCategoryDto();
        result.init(json);
        return result;
    }
}

export interface ICreateExpensePaymentCategoryDto {
    paymentCategoryName: string | undefined;
    isValidForAllPeriods: boolean;
    defaultFromPaymentAccountId: string;
}

export class CreateHousingCategoryDto implements ICreateHousingCategoryDto {
    housingCategoryName: string | undefined;

    constructor(data?: ICreateHousingCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.housingCategoryName = _data["housingCategoryName"];
        }
    }

    static fromJS(data: any): CreateHousingCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateHousingCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["housingCategoryName"] = this.housingCategoryName;
        return data;
    }

    clone(): CreateHousingCategoryDto {
        const json = this.toJSON();
        let result = new CreateHousingCategoryDto();
        result.init(json);
        return result;
    }
}

export interface ICreateHousingCategoryDto {
    housingCategoryName: string | undefined;
}

export class CreateHousingDto implements ICreateHousingDto {
    blockId: string;
    apartment: string | undefined;
    housingCategoryId: string;
    tenantIsResiding: boolean;
    transferForHousingDue: CreateOrUpdateTransferForHousingDueDto;

    constructor(data?: ICreateHousingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.blockId = _data["blockId"];
            this.apartment = _data["apartment"];
            this.housingCategoryId = _data["housingCategoryId"];
            this.tenantIsResiding = _data["tenantIsResiding"];
            this.transferForHousingDue = _data["transferForHousingDue"] ? CreateOrUpdateTransferForHousingDueDto.fromJS(_data["transferForHousingDue"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateHousingDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateHousingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["blockId"] = this.blockId;
        data["apartment"] = this.apartment;
        data["housingCategoryId"] = this.housingCategoryId;
        data["tenantIsResiding"] = this.tenantIsResiding;
        data["transferForHousingDue"] = this.transferForHousingDue ? this.transferForHousingDue.toJSON() : <any>undefined;
        return data;
    }

    clone(): CreateHousingDto {
        const json = this.toJSON();
        let result = new CreateHousingDto();
        result.init(json);
        return result;
    }
}

export interface ICreateHousingDto {
    blockId: string;
    apartment: string | undefined;
    housingCategoryId: string;
    tenantIsResiding: boolean;
    transferForHousingDue: CreateOrUpdateTransferForHousingDueDto;
}

export class CreateHousingPaymentPlanGroupDto implements ICreateHousingPaymentPlanGroupDto {
    housingPaymentPlanGroupName: string | undefined;
    countOfMonth: number;
    defaultToPaymentAccountId: string;
    paymentDayOfMonth: number;
    startDateString: string | undefined;
    description: string | undefined;
    residentOrOwner: ResidentOrOwner;
    housingPaymentPlanGroupForHousings: HousingPaymentPlanGroupForHousingDto[] | undefined;
    housingPaymentPlanGroupForHousingCategories: HousingPaymentPlanGroupForHousingCategoryDto[] | undefined;

    constructor(data?: ICreateHousingPaymentPlanGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.housingPaymentPlanGroupName = _data["housingPaymentPlanGroupName"];
            this.countOfMonth = _data["countOfMonth"];
            this.defaultToPaymentAccountId = _data["defaultToPaymentAccountId"];
            this.paymentDayOfMonth = _data["paymentDayOfMonth"];
            this.startDateString = _data["startDateString"];
            this.description = _data["description"];
            this.residentOrOwner = _data["residentOrOwner"];
            if (Array.isArray(_data["housingPaymentPlanGroupForHousings"])) {
                this.housingPaymentPlanGroupForHousings = [] as any;
                for (let item of _data["housingPaymentPlanGroupForHousings"])
                    this.housingPaymentPlanGroupForHousings.push(HousingPaymentPlanGroupForHousingDto.fromJS(item));
            }
            if (Array.isArray(_data["housingPaymentPlanGroupForHousingCategories"])) {
                this.housingPaymentPlanGroupForHousingCategories = [] as any;
                for (let item of _data["housingPaymentPlanGroupForHousingCategories"])
                    this.housingPaymentPlanGroupForHousingCategories.push(HousingPaymentPlanGroupForHousingCategoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateHousingPaymentPlanGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateHousingPaymentPlanGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["housingPaymentPlanGroupName"] = this.housingPaymentPlanGroupName;
        data["countOfMonth"] = this.countOfMonth;
        data["defaultToPaymentAccountId"] = this.defaultToPaymentAccountId;
        data["paymentDayOfMonth"] = this.paymentDayOfMonth;
        data["startDateString"] = this.startDateString;
        data["description"] = this.description;
        data["residentOrOwner"] = this.residentOrOwner;
        if (Array.isArray(this.housingPaymentPlanGroupForHousings)) {
            data["housingPaymentPlanGroupForHousings"] = [];
            for (let item of this.housingPaymentPlanGroupForHousings)
                data["housingPaymentPlanGroupForHousings"].push(item.toJSON());
        }
        if (Array.isArray(this.housingPaymentPlanGroupForHousingCategories)) {
            data["housingPaymentPlanGroupForHousingCategories"] = [];
            for (let item of this.housingPaymentPlanGroupForHousingCategories)
                data["housingPaymentPlanGroupForHousingCategories"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateHousingPaymentPlanGroupDto {
        const json = this.toJSON();
        let result = new CreateHousingPaymentPlanGroupDto();
        result.init(json);
        return result;
    }
}

export interface ICreateHousingPaymentPlanGroupDto {
    housingPaymentPlanGroupName: string | undefined;
    countOfMonth: number;
    defaultToPaymentAccountId: string;
    paymentDayOfMonth: number;
    startDateString: string | undefined;
    description: string | undefined;
    residentOrOwner: ResidentOrOwner;
    housingPaymentPlanGroupForHousings: HousingPaymentPlanGroupForHousingDto[] | undefined;
    housingPaymentPlanGroupForHousingCategories: HousingPaymentPlanGroupForHousingCategoryDto[] | undefined;
}

export class CreateHousingPersonDto implements ICreateHousingPersonDto {
    housingId: string;
    peopleIds: string[] | undefined;
    isTenant: boolean;
    contact: boolean;

    constructor(data?: ICreateHousingPersonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.housingId = _data["housingId"];
            if (Array.isArray(_data["peopleIds"])) {
                this.peopleIds = [] as any;
                for (let item of _data["peopleIds"])
                    this.peopleIds.push(item);
            }
            this.isTenant = _data["isTenant"];
            this.contact = _data["contact"];
        }
    }

    static fromJS(data: any): CreateHousingPersonDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateHousingPersonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["housingId"] = this.housingId;
        if (Array.isArray(this.peopleIds)) {
            data["peopleIds"] = [];
            for (let item of this.peopleIds)
                data["peopleIds"].push(item);
        }
        data["isTenant"] = this.isTenant;
        data["contact"] = this.contact;
        return data;
    }

    clone(): CreateHousingPersonDto {
        const json = this.toJSON();
        let result = new CreateHousingPersonDto();
        result.init(json);
        return result;
    }
}

export interface ICreateHousingPersonDto {
    housingId: string;
    peopleIds: string[] | undefined;
    isTenant: boolean;
    contact: boolean;
}

export class CreateIncomePaymentCategoryDto implements ICreateIncomePaymentCategoryDto {
    paymentCategoryName: string | undefined;
    isValidForAllPeriods: boolean;
    defaultToPaymentAccountId: string;

    constructor(data?: ICreateIncomePaymentCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentCategoryName = _data["paymentCategoryName"];
            this.isValidForAllPeriods = _data["isValidForAllPeriods"];
            this.defaultToPaymentAccountId = _data["defaultToPaymentAccountId"];
        }
    }

    static fromJS(data: any): CreateIncomePaymentCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateIncomePaymentCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentCategoryName"] = this.paymentCategoryName;
        data["isValidForAllPeriods"] = this.isValidForAllPeriods;
        data["defaultToPaymentAccountId"] = this.defaultToPaymentAccountId;
        return data;
    }

    clone(): CreateIncomePaymentCategoryDto {
        const json = this.toJSON();
        let result = new CreateIncomePaymentCategoryDto();
        result.init(json);
        return result;
    }
}

export interface ICreateIncomePaymentCategoryDto {
    paymentCategoryName: string | undefined;
    isValidForAllPeriods: boolean;
    defaultToPaymentAccountId: string;
}

export class CreateInventoryDto implements ICreateInventoryDto {
    inventoryTypeId: string;
    accountBookId: string | undefined;
    quantity: number;
    serialNumber: string | undefined;
    description: string | undefined;

    constructor(data?: ICreateInventoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.inventoryTypeId = _data["inventoryTypeId"];
            this.accountBookId = _data["accountBookId"];
            this.quantity = _data["quantity"];
            this.serialNumber = _data["serialNumber"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateInventoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInventoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inventoryTypeId"] = this.inventoryTypeId;
        data["accountBookId"] = this.accountBookId;
        data["quantity"] = this.quantity;
        data["serialNumber"] = this.serialNumber;
        data["description"] = this.description;
        return data;
    }

    clone(): CreateInventoryDto {
        const json = this.toJSON();
        let result = new CreateInventoryDto();
        result.init(json);
        return result;
    }
}

export interface ICreateInventoryDto {
    inventoryTypeId: string;
    accountBookId: string | undefined;
    quantity: number;
    serialNumber: string | undefined;
    description: string | undefined;
}

export class CreateInventoryTypeDto implements ICreateInventoryTypeDto {
    inventoryTypeName: string;
    quantityType: QuantityType;

    constructor(data?: ICreateInventoryTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.inventoryTypeName = _data["inventoryTypeName"];
            this.quantityType = _data["quantityType"];
        }
    }

    static fromJS(data: any): CreateInventoryTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInventoryTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inventoryTypeName"] = this.inventoryTypeName;
        data["quantityType"] = this.quantityType;
        return data;
    }

    clone(): CreateInventoryTypeDto {
        const json = this.toJSON();
        let result = new CreateInventoryTypeDto();
        result.init(json);
        return result;
    }
}

export interface ICreateInventoryTypeDto {
    inventoryTypeName: string;
    quantityType: QuantityType;
}

export class CreateOrUpdateTransferForHousingDueDto implements ICreateOrUpdateTransferForHousingDueDto {
    housingId: string;
    residentOrOwner: ResidentOrOwner;
    amount: number | undefined;
    isDebt: boolean;
    transferDateString: string | undefined;
    description: string | undefined;

    constructor(data?: ICreateOrUpdateTransferForHousingDueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.housingId = _data["housingId"];
            this.residentOrOwner = _data["residentOrOwner"];
            this.amount = _data["amount"];
            this.isDebt = _data["isDebt"];
            this.transferDateString = _data["transferDateString"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateOrUpdateTransferForHousingDueDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateTransferForHousingDueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["housingId"] = this.housingId;
        data["residentOrOwner"] = this.residentOrOwner;
        data["amount"] = this.amount;
        data["isDebt"] = this.isDebt;
        data["transferDateString"] = this.transferDateString;
        data["description"] = this.description;
        return data;
    }

    clone(): CreateOrUpdateTransferForHousingDueDto {
        const json = this.toJSON();
        let result = new CreateOrUpdateTransferForHousingDueDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateTransferForHousingDueDto {
    housingId: string;
    residentOrOwner: ResidentOrOwner;
    amount: number | undefined;
    isDebt: boolean;
    transferDateString: string | undefined;
    description: string | undefined;
}

export class CreatePaymentCategoryDto implements ICreatePaymentCategoryDto {
    paymentCategoryName: string | undefined;
    isHousingDue: boolean;
    isValidForAllPeriods: boolean;
    defaultFromPaymentAccountId: string | undefined;
    defaultToPaymentAccountId: string | undefined;

    constructor(data?: ICreatePaymentCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentCategoryName = _data["paymentCategoryName"];
            this.isHousingDue = _data["isHousingDue"];
            this.isValidForAllPeriods = _data["isValidForAllPeriods"];
            this.defaultFromPaymentAccountId = _data["defaultFromPaymentAccountId"];
            this.defaultToPaymentAccountId = _data["defaultToPaymentAccountId"];
        }
    }

    static fromJS(data: any): CreatePaymentCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePaymentCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentCategoryName"] = this.paymentCategoryName;
        data["isHousingDue"] = this.isHousingDue;
        data["isValidForAllPeriods"] = this.isValidForAllPeriods;
        data["defaultFromPaymentAccountId"] = this.defaultFromPaymentAccountId;
        data["defaultToPaymentAccountId"] = this.defaultToPaymentAccountId;
        return data;
    }

    clone(): CreatePaymentCategoryDto {
        const json = this.toJSON();
        let result = new CreatePaymentCategoryDto();
        result.init(json);
        return result;
    }
}

export interface ICreatePaymentCategoryDto {
    paymentCategoryName: string | undefined;
    isHousingDue: boolean;
    isValidForAllPeriods: boolean;
    defaultFromPaymentAccountId: string | undefined;
    defaultToPaymentAccountId: string | undefined;
}

export class CreatePeriodForBlockDto implements ICreatePeriodForBlockDto {
    name: string | undefined;
    startDateString: string | undefined;
    endDateString: string | undefined;
    paymentCategories: string[] | undefined;
    blockId: string;

    constructor(data?: ICreatePeriodForBlockDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.startDateString = _data["startDateString"];
            this.endDateString = _data["endDateString"];
            if (Array.isArray(_data["paymentCategories"])) {
                this.paymentCategories = [] as any;
                for (let item of _data["paymentCategories"])
                    this.paymentCategories.push(item);
            }
            this.blockId = _data["blockId"];
        }
    }

    static fromJS(data: any): CreatePeriodForBlockDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePeriodForBlockDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["startDateString"] = this.startDateString;
        data["endDateString"] = this.endDateString;
        if (Array.isArray(this.paymentCategories)) {
            data["paymentCategories"] = [];
            for (let item of this.paymentCategories)
                data["paymentCategories"].push(item);
        }
        data["blockId"] = this.blockId;
        return data;
    }

    clone(): CreatePeriodForBlockDto {
        const json = this.toJSON();
        let result = new CreatePeriodForBlockDto();
        result.init(json);
        return result;
    }
}

export interface ICreatePeriodForBlockDto {
    name: string | undefined;
    startDateString: string | undefined;
    endDateString: string | undefined;
    paymentCategories: string[] | undefined;
    blockId: string;
}

export class CreatePeriodForSiteDto implements ICreatePeriodForSiteDto {
    name: string | undefined;
    startDateString: string | undefined;
    endDateString: string | undefined;
    paymentCategories: string[] | undefined;

    constructor(data?: ICreatePeriodForSiteDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.startDateString = _data["startDateString"];
            this.endDateString = _data["endDateString"];
            if (Array.isArray(_data["paymentCategories"])) {
                this.paymentCategories = [] as any;
                for (let item of _data["paymentCategories"])
                    this.paymentCategories.push(item);
            }
        }
    }

    static fromJS(data: any): CreatePeriodForSiteDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePeriodForSiteDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["startDateString"] = this.startDateString;
        data["endDateString"] = this.endDateString;
        if (Array.isArray(this.paymentCategories)) {
            data["paymentCategories"] = [];
            for (let item of this.paymentCategories)
                data["paymentCategories"].push(item);
        }
        return data;
    }

    clone(): CreatePeriodForSiteDto {
        const json = this.toJSON();
        let result = new CreatePeriodForSiteDto();
        result.init(json);
        return result;
    }
}

export interface ICreatePeriodForSiteDto {
    name: string | undefined;
    startDateString: string | undefined;
    endDateString: string | undefined;
    paymentCategories: string[] | undefined;
}

export class CreatePersonDto implements ICreatePersonDto {
    firstName: string | undefined;
    lastName: string | undefined;
    phone1: string | undefined;
    phone2: string | undefined;

    constructor(data?: ICreatePersonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.phone1 = _data["phone1"];
            this.phone2 = _data["phone2"];
        }
    }

    static fromJS(data: any): CreatePersonDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePersonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["phone1"] = this.phone1;
        data["phone2"] = this.phone2;
        return data;
    }

    clone(): CreatePersonDto {
        const json = this.toJSON();
        let result = new CreatePersonDto();
        result.init(json);
        return result;
    }
}

export interface ICreatePersonDto {
    firstName: string | undefined;
    lastName: string | undefined;
    phone1: string | undefined;
    phone2: string | undefined;
}

export class CreateRoleDto implements ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;

    constructor(data?: ICreateRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.normalizedName = _data["normalizedName"];
            this.description = _data["description"];
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions.push(item);
            }
        }
    }

    static fromJS(data: any): CreateRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        return data;
    }

    clone(): CreateRoleDto {
        const json = this.toJSON();
        let result = new CreateRoleDto();
        result.init(json);
        return result;
    }
}

export interface ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
}

export class CreateTenantDto implements ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string | undefined;
    isActive: boolean;

    constructor(data?: ICreateTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.adminEmailAddress = _data["adminEmailAddress"];
            this.connectionString = _data["connectionString"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): CreateTenantDto {
        const json = this.toJSON();
        let result = new CreateTenantDto();
        result.init(json);
        return result;
    }
}

export interface ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string | undefined;
    isActive: boolean;
}

export class CreateTransferPaymentCategoryDto implements ICreateTransferPaymentCategoryDto {
    paymentCategoryName: string | undefined;
    isValidForAllPeriods: boolean;
    defaultFromPaymentAccountId: string;
    defaultToPaymentAccountId: string;

    constructor(data?: ICreateTransferPaymentCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentCategoryName = _data["paymentCategoryName"];
            this.isValidForAllPeriods = _data["isValidForAllPeriods"];
            this.defaultFromPaymentAccountId = _data["defaultFromPaymentAccountId"];
            this.defaultToPaymentAccountId = _data["defaultToPaymentAccountId"];
        }
    }

    static fromJS(data: any): CreateTransferPaymentCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTransferPaymentCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentCategoryName"] = this.paymentCategoryName;
        data["isValidForAllPeriods"] = this.isValidForAllPeriods;
        data["defaultFromPaymentAccountId"] = this.defaultFromPaymentAccountId;
        data["defaultToPaymentAccountId"] = this.defaultToPaymentAccountId;
        return data;
    }

    clone(): CreateTransferPaymentCategoryDto {
        const json = this.toJSON();
        let result = new CreateTransferPaymentCategoryDto();
        result.init(json);
        return result;
    }
}

export interface ICreateTransferPaymentCategoryDto {
    paymentCategoryName: string | undefined;
    isValidForAllPeriods: boolean;
    defaultFromPaymentAccountId: string;
    defaultToPaymentAccountId: string;
}

export class CreateUserDto implements ICreateUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    roleNames: string[] | undefined;
    password: string;

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames.push(item);
            }
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): CreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["password"] = this.password;
        return data;
    }

    clone(): CreateUserDto {
        const json = this.toJSON();
        let result = new CreateUserDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    roleNames: string[] | undefined;
    password: string;
}

export enum CreditOrDebt {
    Credit = 1,
    Debt = 2,
}

export class DashboardDto implements IDashboardDto {
    paymentAccounts: PaymentAccountDashboardDto[] | undefined;
    totalHousingDueAmount: number;
    totalIncomeAmount: number;
    totalExpenseAmount: number;
    mostHousingDueBalances: HousingDueBalancesDashboardDto[] | undefined;
    lessHousingDueBalances: HousingDueBalancesDashboardDto[] | undefined;
    mostHousingDuePayers: HousingDuePayersDashboardDto[] | undefined;
    lessHousingDuePayers: HousingDuePayersDashboardDto[] | undefined;
    expensesData: PaymentCategoryDashboardDto[] | undefined;
    totalHousingDueStatsDto: TotalHousingDueStatsDto;

    constructor(data?: IDashboardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["paymentAccounts"])) {
                this.paymentAccounts = [] as any;
                for (let item of _data["paymentAccounts"])
                    this.paymentAccounts.push(PaymentAccountDashboardDto.fromJS(item));
            }
            this.totalHousingDueAmount = _data["totalHousingDueAmount"];
            this.totalIncomeAmount = _data["totalIncomeAmount"];
            this.totalExpenseAmount = _data["totalExpenseAmount"];
            if (Array.isArray(_data["mostHousingDueBalances"])) {
                this.mostHousingDueBalances = [] as any;
                for (let item of _data["mostHousingDueBalances"])
                    this.mostHousingDueBalances.push(HousingDueBalancesDashboardDto.fromJS(item));
            }
            if (Array.isArray(_data["lessHousingDueBalances"])) {
                this.lessHousingDueBalances = [] as any;
                for (let item of _data["lessHousingDueBalances"])
                    this.lessHousingDueBalances.push(HousingDueBalancesDashboardDto.fromJS(item));
            }
            if (Array.isArray(_data["mostHousingDuePayers"])) {
                this.mostHousingDuePayers = [] as any;
                for (let item of _data["mostHousingDuePayers"])
                    this.mostHousingDuePayers.push(HousingDuePayersDashboardDto.fromJS(item));
            }
            if (Array.isArray(_data["lessHousingDuePayers"])) {
                this.lessHousingDuePayers = [] as any;
                for (let item of _data["lessHousingDuePayers"])
                    this.lessHousingDuePayers.push(HousingDuePayersDashboardDto.fromJS(item));
            }
            if (Array.isArray(_data["expensesData"])) {
                this.expensesData = [] as any;
                for (let item of _data["expensesData"])
                    this.expensesData.push(PaymentCategoryDashboardDto.fromJS(item));
            }
            this.totalHousingDueStatsDto = _data["totalHousingDueStatsDto"] ? TotalHousingDueStatsDto.fromJS(_data["totalHousingDueStatsDto"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DashboardDto {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.paymentAccounts)) {
            data["paymentAccounts"] = [];
            for (let item of this.paymentAccounts)
                data["paymentAccounts"].push(item.toJSON());
        }
        data["totalHousingDueAmount"] = this.totalHousingDueAmount;
        data["totalIncomeAmount"] = this.totalIncomeAmount;
        data["totalExpenseAmount"] = this.totalExpenseAmount;
        if (Array.isArray(this.mostHousingDueBalances)) {
            data["mostHousingDueBalances"] = [];
            for (let item of this.mostHousingDueBalances)
                data["mostHousingDueBalances"].push(item.toJSON());
        }
        if (Array.isArray(this.lessHousingDueBalances)) {
            data["lessHousingDueBalances"] = [];
            for (let item of this.lessHousingDueBalances)
                data["lessHousingDueBalances"].push(item.toJSON());
        }
        if (Array.isArray(this.mostHousingDuePayers)) {
            data["mostHousingDuePayers"] = [];
            for (let item of this.mostHousingDuePayers)
                data["mostHousingDuePayers"].push(item.toJSON());
        }
        if (Array.isArray(this.lessHousingDuePayers)) {
            data["lessHousingDuePayers"] = [];
            for (let item of this.lessHousingDuePayers)
                data["lessHousingDuePayers"].push(item.toJSON());
        }
        if (Array.isArray(this.expensesData)) {
            data["expensesData"] = [];
            for (let item of this.expensesData)
                data["expensesData"].push(item.toJSON());
        }
        data["totalHousingDueStatsDto"] = this.totalHousingDueStatsDto ? this.totalHousingDueStatsDto.toJSON() : <any>undefined;
        return data;
    }

    clone(): DashboardDto {
        const json = this.toJSON();
        let result = new DashboardDto();
        result.init(json);
        return result;
    }
}

export interface IDashboardDto {
    paymentAccounts: PaymentAccountDashboardDto[] | undefined;
    totalHousingDueAmount: number;
    totalIncomeAmount: number;
    totalExpenseAmount: number;
    mostHousingDueBalances: HousingDueBalancesDashboardDto[] | undefined;
    lessHousingDueBalances: HousingDueBalancesDashboardDto[] | undefined;
    mostHousingDuePayers: HousingDuePayersDashboardDto[] | undefined;
    lessHousingDuePayers: HousingDuePayersDashboardDto[] | undefined;
    expensesData: PaymentCategoryDashboardDto[] | undefined;
    totalHousingDueStatsDto: TotalHousingDueStatsDto;
}

export class EmployeeDto implements IEmployeeDto {
    id: string;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    name: string | undefined;
    phone1: string | undefined;
    phone2: string | undefined;

    constructor(data?: IEmployeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.name = _data["name"];
            this.phone1 = _data["phone1"];
            this.phone2 = _data["phone2"];
        }
    }

    static fromJS(data: any): EmployeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["name"] = this.name;
        data["phone1"] = this.phone1;
        data["phone2"] = this.phone2;
        return data;
    }

    clone(): EmployeeDto {
        const json = this.toJSON();
        let result = new EmployeeDto();
        result.init(json);
        return result;
    }
}

export interface IEmployeeDto {
    id: string;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    name: string | undefined;
    phone1: string | undefined;
    phone2: string | undefined;
}

export class EmployeeDtoPagedResultDto implements IEmployeeDtoPagedResultDto {
    items: EmployeeDto[] | undefined;
    totalCount: number;

    constructor(data?: IEmployeeDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(EmployeeDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): EmployeeDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): EmployeeDtoPagedResultDto {
        const json = this.toJSON();
        let result = new EmployeeDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IEmployeeDtoPagedResultDto {
    items: EmployeeDto[] | undefined;
    totalCount: number;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authProvider = _data["authProvider"];
            this.providerKey = _data["providerKey"];
            this.providerAccessCode = _data["providerAccessCode"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        return data;
    }

    clone(): ExternalAuthenticateModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.waitingForActivation = _data["waitingForActivation"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        return data;
    }

    clone(): ExternalAuthenticateResultModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.clientId = _data["clientId"];
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        return data;
    }

    clone(): ExternalLoginProviderInfoModel {
        const json = this.toJSON();
        let result = new ExternalLoginProviderInfoModel();
        result.init(json);
        return result;
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
}

export class FinancialStatementDto implements IFinancialStatementDto {
    title: string[] | undefined;
    incomesTitle: string | undefined;
    incomes: ReportLine[] | undefined;
    initialAmounts: ReportLine[] | undefined;
    incomeTotal: ReportLine;
    incomeTotalWithInitialAmounts: ReportLine;
    expensesTitle: string | undefined;
    expenses: ReportLine[] | undefined;
    finallyAmounts: ReportLine[] | undefined;
    expenseTotal: ReportLine;
    expenseTotalWithFinallyAmounts: ReportLine;

    constructor(data?: IFinancialStatementDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["title"])) {
                this.title = [] as any;
                for (let item of _data["title"])
                    this.title.push(item);
            }
            this.incomesTitle = _data["incomesTitle"];
            if (Array.isArray(_data["incomes"])) {
                this.incomes = [] as any;
                for (let item of _data["incomes"])
                    this.incomes.push(ReportLine.fromJS(item));
            }
            if (Array.isArray(_data["initialAmounts"])) {
                this.initialAmounts = [] as any;
                for (let item of _data["initialAmounts"])
                    this.initialAmounts.push(ReportLine.fromJS(item));
            }
            this.incomeTotal = _data["incomeTotal"] ? ReportLine.fromJS(_data["incomeTotal"]) : <any>undefined;
            this.incomeTotalWithInitialAmounts = _data["incomeTotalWithInitialAmounts"] ? ReportLine.fromJS(_data["incomeTotalWithInitialAmounts"]) : <any>undefined;
            this.expensesTitle = _data["expensesTitle"];
            if (Array.isArray(_data["expenses"])) {
                this.expenses = [] as any;
                for (let item of _data["expenses"])
                    this.expenses.push(ReportLine.fromJS(item));
            }
            if (Array.isArray(_data["finallyAmounts"])) {
                this.finallyAmounts = [] as any;
                for (let item of _data["finallyAmounts"])
                    this.finallyAmounts.push(ReportLine.fromJS(item));
            }
            this.expenseTotal = _data["expenseTotal"] ? ReportLine.fromJS(_data["expenseTotal"]) : <any>undefined;
            this.expenseTotalWithFinallyAmounts = _data["expenseTotalWithFinallyAmounts"] ? ReportLine.fromJS(_data["expenseTotalWithFinallyAmounts"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FinancialStatementDto {
        data = typeof data === 'object' ? data : {};
        let result = new FinancialStatementDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.title)) {
            data["title"] = [];
            for (let item of this.title)
                data["title"].push(item);
        }
        data["incomesTitle"] = this.incomesTitle;
        if (Array.isArray(this.incomes)) {
            data["incomes"] = [];
            for (let item of this.incomes)
                data["incomes"].push(item.toJSON());
        }
        if (Array.isArray(this.initialAmounts)) {
            data["initialAmounts"] = [];
            for (let item of this.initialAmounts)
                data["initialAmounts"].push(item.toJSON());
        }
        data["incomeTotal"] = this.incomeTotal ? this.incomeTotal.toJSON() : <any>undefined;
        data["incomeTotalWithInitialAmounts"] = this.incomeTotalWithInitialAmounts ? this.incomeTotalWithInitialAmounts.toJSON() : <any>undefined;
        data["expensesTitle"] = this.expensesTitle;
        if (Array.isArray(this.expenses)) {
            data["expenses"] = [];
            for (let item of this.expenses)
                data["expenses"].push(item.toJSON());
        }
        if (Array.isArray(this.finallyAmounts)) {
            data["finallyAmounts"] = [];
            for (let item of this.finallyAmounts)
                data["finallyAmounts"].push(item.toJSON());
        }
        data["expenseTotal"] = this.expenseTotal ? this.expenseTotal.toJSON() : <any>undefined;
        data["expenseTotalWithFinallyAmounts"] = this.expenseTotalWithFinallyAmounts ? this.expenseTotalWithFinallyAmounts.toJSON() : <any>undefined;
        return data;
    }

    clone(): FinancialStatementDto {
        const json = this.toJSON();
        let result = new FinancialStatementDto();
        result.init(json);
        return result;
    }
}

export interface IFinancialStatementDto {
    title: string[] | undefined;
    incomesTitle: string | undefined;
    incomes: ReportLine[] | undefined;
    initialAmounts: ReportLine[] | undefined;
    incomeTotal: ReportLine;
    incomeTotalWithInitialAmounts: ReportLine;
    expensesTitle: string | undefined;
    expenses: ReportLine[] | undefined;
    finallyAmounts: ReportLine[] | undefined;
    expenseTotal: ReportLine;
    expenseTotalWithFinallyAmounts: ReportLine;
}

export class FlatPermissionDto implements IFlatPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;

    constructor(data?: IFlatPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): FlatPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data;
    }

    clone(): FlatPermissionDto {
        const json = this.toJSON();
        let result = new FlatPermissionDto();
        result.init(json);
        return result;
    }
}

export interface IFlatPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto;
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.application = _data["application"] ? ApplicationInfoDto.fromJS(_data["application"]) : <any>undefined;
            this.user = _data["user"] ? UserLoginInfoDto.fromJS(_data["user"]) : <any>undefined;
            this.tenant = _data["tenant"] ? TenantLoginInfoDto.fromJS(_data["tenant"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        return data;
    }

    clone(): GetCurrentLoginInformationsOutput {
        const json = this.toJSON();
        let result = new GetCurrentLoginInformationsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto;
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    role: RoleEditDto;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data["role"] ? RoleEditDto.fromJS(_data["role"]) : <any>undefined;
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions.push(FlatPermissionDto.fromJS(item));
            }
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data;
    }

    clone(): GetRoleForEditOutput {
        const json = this.toJSON();
        let result = new GetRoleForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetRoleForEditOutput {
    role: RoleEditDto;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class HousingCategoryDto implements IHousingCategoryDto {
    id: string;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    housingCategoryName: string | undefined;

    constructor(data?: IHousingCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.housingCategoryName = _data["housingCategoryName"];
        }
    }

    static fromJS(data: any): HousingCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new HousingCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["housingCategoryName"] = this.housingCategoryName;
        return data;
    }

    clone(): HousingCategoryDto {
        const json = this.toJSON();
        let result = new HousingCategoryDto();
        result.init(json);
        return result;
    }
}

export interface IHousingCategoryDto {
    id: string;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    housingCategoryName: string | undefined;
}

export class HousingCategoryDtoPagedResultDto implements IHousingCategoryDtoPagedResultDto {
    items: HousingCategoryDto[] | undefined;
    totalCount: number;

    constructor(data?: IHousingCategoryDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(HousingCategoryDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): HousingCategoryDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new HousingCategoryDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): HousingCategoryDtoPagedResultDto {
        const json = this.toJSON();
        let result = new HousingCategoryDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IHousingCategoryDtoPagedResultDto {
    items: HousingCategoryDto[] | undefined;
    totalCount: number;
}

export class HousingDto implements IHousingDto {
    id: string;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    blockId: string;
    apartment: string | undefined;
    housingCategoryId: string;
    balance: number;
    residentBalance: number;
    ownerBalance: number;
    tenantIsResiding: boolean;
    firstHousingDueTransferPaymentPlan: HousingPaymentPlanDto;
    block: Block;
    housingCategory: HousingCategoryDto;
    housingPerson: HousingPersonDto;

    constructor(data?: IHousingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.blockId = _data["blockId"];
            this.apartment = _data["apartment"];
            this.housingCategoryId = _data["housingCategoryId"];
            this.balance = _data["balance"];
            this.residentBalance = _data["residentBalance"];
            this.ownerBalance = _data["ownerBalance"];
            this.tenantIsResiding = _data["tenantIsResiding"];
            this.firstHousingDueTransferPaymentPlan = _data["firstHousingDueTransferPaymentPlan"] ? HousingPaymentPlanDto.fromJS(_data["firstHousingDueTransferPaymentPlan"]) : <any>undefined;
            this.block = _data["block"] ? Block.fromJS(_data["block"]) : <any>undefined;
            this.housingCategory = _data["housingCategory"] ? HousingCategoryDto.fromJS(_data["housingCategory"]) : <any>undefined;
            this.housingPerson = _data["housingPerson"] ? HousingPersonDto.fromJS(_data["housingPerson"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HousingDto {
        data = typeof data === 'object' ? data : {};
        let result = new HousingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["blockId"] = this.blockId;
        data["apartment"] = this.apartment;
        data["housingCategoryId"] = this.housingCategoryId;
        data["balance"] = this.balance;
        data["residentBalance"] = this.residentBalance;
        data["ownerBalance"] = this.ownerBalance;
        data["tenantIsResiding"] = this.tenantIsResiding;
        data["firstHousingDueTransferPaymentPlan"] = this.firstHousingDueTransferPaymentPlan ? this.firstHousingDueTransferPaymentPlan.toJSON() : <any>undefined;
        data["block"] = this.block ? this.block.toJSON() : <any>undefined;
        data["housingCategory"] = this.housingCategory ? this.housingCategory.toJSON() : <any>undefined;
        data["housingPerson"] = this.housingPerson ? this.housingPerson.toJSON() : <any>undefined;
        return data;
    }

    clone(): HousingDto {
        const json = this.toJSON();
        let result = new HousingDto();
        result.init(json);
        return result;
    }
}

export interface IHousingDto {
    id: string;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    blockId: string;
    apartment: string | undefined;
    housingCategoryId: string;
    balance: number;
    residentBalance: number;
    ownerBalance: number;
    tenantIsResiding: boolean;
    firstHousingDueTransferPaymentPlan: HousingPaymentPlanDto;
    block: Block;
    housingCategory: HousingCategoryDto;
    housingPerson: HousingPersonDto;
}

export class HousingDtoPagedResultDto implements IHousingDtoPagedResultDto {
    items: HousingDto[] | undefined;
    totalCount: number;

    constructor(data?: IHousingDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(HousingDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): HousingDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new HousingDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): HousingDtoPagedResultDto {
        const json = this.toJSON();
        let result = new HousingDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IHousingDtoPagedResultDto {
    items: HousingDto[] | undefined;
    totalCount: number;
}

export class HousingDueBalancesDashboardDto implements IHousingDueBalancesDashboardDto {
    housingId: string;
    housingName: string | undefined;
    balance: number;

    constructor(data?: IHousingDueBalancesDashboardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.housingId = _data["housingId"];
            this.housingName = _data["housingName"];
            this.balance = _data["balance"];
        }
    }

    static fromJS(data: any): HousingDueBalancesDashboardDto {
        data = typeof data === 'object' ? data : {};
        let result = new HousingDueBalancesDashboardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["housingId"] = this.housingId;
        data["housingName"] = this.housingName;
        data["balance"] = this.balance;
        return data;
    }

    clone(): HousingDueBalancesDashboardDto {
        const json = this.toJSON();
        let result = new HousingDueBalancesDashboardDto();
        result.init(json);
        return result;
    }
}

export interface IHousingDueBalancesDashboardDto {
    housingId: string;
    housingName: string | undefined;
    balance: number;
}

export class HousingDuePayersDashboardDto implements IHousingDuePayersDashboardDto {
    housingName: string | undefined;
    totalHousingDueAmount: number;

    constructor(data?: IHousingDuePayersDashboardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.housingName = _data["housingName"];
            this.totalHousingDueAmount = _data["totalHousingDueAmount"];
        }
    }

    static fromJS(data: any): HousingDuePayersDashboardDto {
        data = typeof data === 'object' ? data : {};
        let result = new HousingDuePayersDashboardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["housingName"] = this.housingName;
        data["totalHousingDueAmount"] = this.totalHousingDueAmount;
        return data;
    }

    clone(): HousingDuePayersDashboardDto {
        const json = this.toJSON();
        let result = new HousingDuePayersDashboardDto();
        result.init(json);
        return result;
    }
}

export interface IHousingDuePayersDashboardDto {
    housingName: string | undefined;
    totalHousingDueAmount: number;
}

export class HousingForListDto implements IHousingForListDto {
    id: string;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    block: string | undefined;
    apartment: string | undefined;
    housingCategoryName: string | undefined;
    tenantIsResiding: boolean;
    balance: number;
    residentBalance: number;
    ownerBalance: number;

    constructor(data?: IHousingForListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.block = _data["block"];
            this.apartment = _data["apartment"];
            this.housingCategoryName = _data["housingCategoryName"];
            this.tenantIsResiding = _data["tenantIsResiding"];
            this.balance = _data["balance"];
            this.residentBalance = _data["residentBalance"];
            this.ownerBalance = _data["ownerBalance"];
        }
    }

    static fromJS(data: any): HousingForListDto {
        data = typeof data === 'object' ? data : {};
        let result = new HousingForListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["block"] = this.block;
        data["apartment"] = this.apartment;
        data["housingCategoryName"] = this.housingCategoryName;
        data["tenantIsResiding"] = this.tenantIsResiding;
        data["balance"] = this.balance;
        data["residentBalance"] = this.residentBalance;
        data["ownerBalance"] = this.ownerBalance;
        return data;
    }

    clone(): HousingForListDto {
        const json = this.toJSON();
        let result = new HousingForListDto();
        result.init(json);
        return result;
    }
}

export interface IHousingForListDto {
    id: string;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    block: string | undefined;
    apartment: string | undefined;
    housingCategoryName: string | undefined;
    tenantIsResiding: boolean;
    balance: number;
    residentBalance: number;
    ownerBalance: number;
}

export class HousingForListDtoPagedResultDto implements IHousingForListDtoPagedResultDto {
    items: HousingForListDto[] | undefined;
    totalCount: number;

    constructor(data?: IHousingForListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(HousingForListDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): HousingForListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new HousingForListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): HousingForListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new HousingForListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IHousingForListDtoPagedResultDto {
    items: HousingForListDto[] | undefined;
    totalCount: number;
}

export class HousingPaymentPlanDto implements IHousingPaymentPlanDto {
    id: string;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    housingId: string;
    paymentCategoryId: string;
    date: moment.Moment;
    creditOrDebt: CreditOrDebt;
    housingPaymentPlanType: HousingPaymentPlanType;
    amount: number;
    description: string | undefined;
    accountBookId: string | undefined;
    firstHousingDueTransferIsResidentOrOwner: ResidentOrOwner;
    paymentCategory: PaymentCategoryDto;

    constructor(data?: IHousingPaymentPlanDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.housingId = _data["housingId"];
            this.paymentCategoryId = _data["paymentCategoryId"];
            this.date = _data["date"] ? moment(_data["date"].toString()) : <any>undefined;
            this.creditOrDebt = _data["creditOrDebt"];
            this.housingPaymentPlanType = _data["housingPaymentPlanType"];
            this.amount = _data["amount"];
            this.description = _data["description"];
            this.accountBookId = _data["accountBookId"];
            this.firstHousingDueTransferIsResidentOrOwner = _data["firstHousingDueTransferIsResidentOrOwner"];
            this.paymentCategory = _data["paymentCategory"] ? PaymentCategoryDto.fromJS(_data["paymentCategory"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HousingPaymentPlanDto {
        data = typeof data === 'object' ? data : {};
        let result = new HousingPaymentPlanDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["housingId"] = this.housingId;
        data["paymentCategoryId"] = this.paymentCategoryId;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["creditOrDebt"] = this.creditOrDebt;
        data["housingPaymentPlanType"] = this.housingPaymentPlanType;
        data["amount"] = this.amount;
        data["description"] = this.description;
        data["accountBookId"] = this.accountBookId;
        data["firstHousingDueTransferIsResidentOrOwner"] = this.firstHousingDueTransferIsResidentOrOwner;
        data["paymentCategory"] = this.paymentCategory ? this.paymentCategory.toJSON() : <any>undefined;
        return data;
    }

    clone(): HousingPaymentPlanDto {
        const json = this.toJSON();
        let result = new HousingPaymentPlanDto();
        result.init(json);
        return result;
    }
}

export interface IHousingPaymentPlanDto {
    id: string;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    housingId: string;
    paymentCategoryId: string;
    date: moment.Moment;
    creditOrDebt: CreditOrDebt;
    housingPaymentPlanType: HousingPaymentPlanType;
    amount: number;
    description: string | undefined;
    accountBookId: string | undefined;
    firstHousingDueTransferIsResidentOrOwner: ResidentOrOwner;
    paymentCategory: PaymentCategoryDto;
}

export class HousingPaymentPlanDtoPagedResultDto implements IHousingPaymentPlanDtoPagedResultDto {
    items: HousingPaymentPlanDto[] | undefined;
    totalCount: number;

    constructor(data?: IHousingPaymentPlanDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(HousingPaymentPlanDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): HousingPaymentPlanDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new HousingPaymentPlanDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): HousingPaymentPlanDtoPagedResultDto {
        const json = this.toJSON();
        let result = new HousingPaymentPlanDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IHousingPaymentPlanDtoPagedResultDto {
    items: HousingPaymentPlanDto[] | undefined;
    totalCount: number;
}

export class HousingPaymentPlanExportOutput implements IHousingPaymentPlanExportOutput {
    date: string | undefined;
    creditOrDebt: string | undefined;
    paymentCategory: string | undefined;
    housingPaymentPlanType: string | undefined;
    amount: number;

    constructor(data?: IHousingPaymentPlanExportOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"];
            this.creditOrDebt = _data["creditOrDebt"];
            this.paymentCategory = _data["paymentCategory"];
            this.housingPaymentPlanType = _data["housingPaymentPlanType"];
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): HousingPaymentPlanExportOutput {
        data = typeof data === 'object' ? data : {};
        let result = new HousingPaymentPlanExportOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["creditOrDebt"] = this.creditOrDebt;
        data["paymentCategory"] = this.paymentCategory;
        data["housingPaymentPlanType"] = this.housingPaymentPlanType;
        data["amount"] = this.amount;
        return data;
    }

    clone(): HousingPaymentPlanExportOutput {
        const json = this.toJSON();
        let result = new HousingPaymentPlanExportOutput();
        result.init(json);
        return result;
    }
}

export interface IHousingPaymentPlanExportOutput {
    date: string | undefined;
    creditOrDebt: string | undefined;
    paymentCategory: string | undefined;
    housingPaymentPlanType: string | undefined;
    amount: number;
}

export class HousingPaymentPlanGroupDto implements IHousingPaymentPlanGroupDto {
    id: string;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    housingPaymentPlanGroupName: string | undefined;
    paymentCategoryId: string;
    countOfMonth: number;
    paymentDayOfMonth: number;
    startDate: moment.Moment;
    description: string | undefined;
    residentOrOwner: ResidentOrOwner;
    housingCategoryNames: string | undefined;
    housingNames: string | undefined;
    housingCategory: HousingCategoryDto;
    paymentCategory: PaymentCategoryDto;
    housingPaymentPlanGroupHousingCategories: HousingPaymentPlanGroupHousingCategoryDto[] | undefined;
    housingPaymentPlanGroupHousings: HousingPaymentPlanGroupHousingDto[] | undefined;

    constructor(data?: IHousingPaymentPlanGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.housingPaymentPlanGroupName = _data["housingPaymentPlanGroupName"];
            this.paymentCategoryId = _data["paymentCategoryId"];
            this.countOfMonth = _data["countOfMonth"];
            this.paymentDayOfMonth = _data["paymentDayOfMonth"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.residentOrOwner = _data["residentOrOwner"];
            this.housingCategoryNames = _data["housingCategoryNames"];
            this.housingNames = _data["housingNames"];
            this.housingCategory = _data["housingCategory"] ? HousingCategoryDto.fromJS(_data["housingCategory"]) : <any>undefined;
            this.paymentCategory = _data["paymentCategory"] ? PaymentCategoryDto.fromJS(_data["paymentCategory"]) : <any>undefined;
            if (Array.isArray(_data["housingPaymentPlanGroupHousingCategories"])) {
                this.housingPaymentPlanGroupHousingCategories = [] as any;
                for (let item of _data["housingPaymentPlanGroupHousingCategories"])
                    this.housingPaymentPlanGroupHousingCategories.push(HousingPaymentPlanGroupHousingCategoryDto.fromJS(item));
            }
            if (Array.isArray(_data["housingPaymentPlanGroupHousings"])) {
                this.housingPaymentPlanGroupHousings = [] as any;
                for (let item of _data["housingPaymentPlanGroupHousings"])
                    this.housingPaymentPlanGroupHousings.push(HousingPaymentPlanGroupHousingDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HousingPaymentPlanGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new HousingPaymentPlanGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["housingPaymentPlanGroupName"] = this.housingPaymentPlanGroupName;
        data["paymentCategoryId"] = this.paymentCategoryId;
        data["countOfMonth"] = this.countOfMonth;
        data["paymentDayOfMonth"] = this.paymentDayOfMonth;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["residentOrOwner"] = this.residentOrOwner;
        data["housingCategoryNames"] = this.housingCategoryNames;
        data["housingNames"] = this.housingNames;
        data["housingCategory"] = this.housingCategory ? this.housingCategory.toJSON() : <any>undefined;
        data["paymentCategory"] = this.paymentCategory ? this.paymentCategory.toJSON() : <any>undefined;
        if (Array.isArray(this.housingPaymentPlanGroupHousingCategories)) {
            data["housingPaymentPlanGroupHousingCategories"] = [];
            for (let item of this.housingPaymentPlanGroupHousingCategories)
                data["housingPaymentPlanGroupHousingCategories"].push(item.toJSON());
        }
        if (Array.isArray(this.housingPaymentPlanGroupHousings)) {
            data["housingPaymentPlanGroupHousings"] = [];
            for (let item of this.housingPaymentPlanGroupHousings)
                data["housingPaymentPlanGroupHousings"].push(item.toJSON());
        }
        return data;
    }

    clone(): HousingPaymentPlanGroupDto {
        const json = this.toJSON();
        let result = new HousingPaymentPlanGroupDto();
        result.init(json);
        return result;
    }
}

export interface IHousingPaymentPlanGroupDto {
    id: string;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    housingPaymentPlanGroupName: string | undefined;
    paymentCategoryId: string;
    countOfMonth: number;
    paymentDayOfMonth: number;
    startDate: moment.Moment;
    description: string | undefined;
    residentOrOwner: ResidentOrOwner;
    housingCategoryNames: string | undefined;
    housingNames: string | undefined;
    housingCategory: HousingCategoryDto;
    paymentCategory: PaymentCategoryDto;
    housingPaymentPlanGroupHousingCategories: HousingPaymentPlanGroupHousingCategoryDto[] | undefined;
    housingPaymentPlanGroupHousings: HousingPaymentPlanGroupHousingDto[] | undefined;
}

export class HousingPaymentPlanGroupDtoPagedResultDto implements IHousingPaymentPlanGroupDtoPagedResultDto {
    items: HousingPaymentPlanGroupDto[] | undefined;
    totalCount: number;

    constructor(data?: IHousingPaymentPlanGroupDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(HousingPaymentPlanGroupDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): HousingPaymentPlanGroupDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new HousingPaymentPlanGroupDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): HousingPaymentPlanGroupDtoPagedResultDto {
        const json = this.toJSON();
        let result = new HousingPaymentPlanGroupDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IHousingPaymentPlanGroupDtoPagedResultDto {
    items: HousingPaymentPlanGroupDto[] | undefined;
    totalCount: number;
}

export class HousingPaymentPlanGroupForHousingCategoryDto implements IHousingPaymentPlanGroupForHousingCategoryDto {
    housingCategoryId: string;
    amountPerMonth: number;

    constructor(data?: IHousingPaymentPlanGroupForHousingCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.housingCategoryId = _data["housingCategoryId"];
            this.amountPerMonth = _data["amountPerMonth"];
        }
    }

    static fromJS(data: any): HousingPaymentPlanGroupForHousingCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new HousingPaymentPlanGroupForHousingCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["housingCategoryId"] = this.housingCategoryId;
        data["amountPerMonth"] = this.amountPerMonth;
        return data;
    }

    clone(): HousingPaymentPlanGroupForHousingCategoryDto {
        const json = this.toJSON();
        let result = new HousingPaymentPlanGroupForHousingCategoryDto();
        result.init(json);
        return result;
    }
}

export interface IHousingPaymentPlanGroupForHousingCategoryDto {
    housingCategoryId: string;
    amountPerMonth: number;
}

export class HousingPaymentPlanGroupForHousingDto implements IHousingPaymentPlanGroupForHousingDto {
    housingId: string;
    amountPerMonth: number;

    constructor(data?: IHousingPaymentPlanGroupForHousingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.housingId = _data["housingId"];
            this.amountPerMonth = _data["amountPerMonth"];
        }
    }

    static fromJS(data: any): HousingPaymentPlanGroupForHousingDto {
        data = typeof data === 'object' ? data : {};
        let result = new HousingPaymentPlanGroupForHousingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["housingId"] = this.housingId;
        data["amountPerMonth"] = this.amountPerMonth;
        return data;
    }

    clone(): HousingPaymentPlanGroupForHousingDto {
        const json = this.toJSON();
        let result = new HousingPaymentPlanGroupForHousingDto();
        result.init(json);
        return result;
    }
}

export interface IHousingPaymentPlanGroupForHousingDto {
    housingId: string;
    amountPerMonth: number;
}

export class HousingPaymentPlanGroupHousingCategoryDto implements IHousingPaymentPlanGroupHousingCategoryDto {
    id: string;
    tenantId: number;
    housingCategoryId: string;
    housingPaymentPlanGroupId: string;
    amountPerMonth: number;

    constructor(data?: IHousingPaymentPlanGroupHousingCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.housingCategoryId = _data["housingCategoryId"];
            this.housingPaymentPlanGroupId = _data["housingPaymentPlanGroupId"];
            this.amountPerMonth = _data["amountPerMonth"];
        }
    }

    static fromJS(data: any): HousingPaymentPlanGroupHousingCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new HousingPaymentPlanGroupHousingCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["housingCategoryId"] = this.housingCategoryId;
        data["housingPaymentPlanGroupId"] = this.housingPaymentPlanGroupId;
        data["amountPerMonth"] = this.amountPerMonth;
        return data;
    }

    clone(): HousingPaymentPlanGroupHousingCategoryDto {
        const json = this.toJSON();
        let result = new HousingPaymentPlanGroupHousingCategoryDto();
        result.init(json);
        return result;
    }
}

export interface IHousingPaymentPlanGroupHousingCategoryDto {
    id: string;
    tenantId: number;
    housingCategoryId: string;
    housingPaymentPlanGroupId: string;
    amountPerMonth: number;
}

export class HousingPaymentPlanGroupHousingDto implements IHousingPaymentPlanGroupHousingDto {
    id: string;
    tenantId: number;
    housingId: string;
    housingPaymentPlanGroupId: string;
    amountPerMonth: number;

    constructor(data?: IHousingPaymentPlanGroupHousingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.housingId = _data["housingId"];
            this.housingPaymentPlanGroupId = _data["housingPaymentPlanGroupId"];
            this.amountPerMonth = _data["amountPerMonth"];
        }
    }

    static fromJS(data: any): HousingPaymentPlanGroupHousingDto {
        data = typeof data === 'object' ? data : {};
        let result = new HousingPaymentPlanGroupHousingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["housingId"] = this.housingId;
        data["housingPaymentPlanGroupId"] = this.housingPaymentPlanGroupId;
        data["amountPerMonth"] = this.amountPerMonth;
        return data;
    }

    clone(): HousingPaymentPlanGroupHousingDto {
        const json = this.toJSON();
        let result = new HousingPaymentPlanGroupHousingDto();
        result.init(json);
        return result;
    }
}

export interface IHousingPaymentPlanGroupHousingDto {
    id: string;
    tenantId: number;
    housingId: string;
    housingPaymentPlanGroupId: string;
    amountPerMonth: number;
}

export enum HousingPaymentPlanType {
    HousingDueDefinition = 1,
    HousingDuePayment = 2,
    Transfer = 3,
    Netting = 4,
    TransferForHousingDuePaymentToNextPeriod = 5,
    TransferForHousingDuePaymentFromPreviousPeriod = 6,
}

export class HousingPersonDto implements IHousingPersonDto {
    id: string;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    housingId: string;
    personId: string;
    isTenant: boolean;
    contact: boolean;
    person: PersonDto;
    housing: HousingDto;

    constructor(data?: IHousingPersonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.housingId = _data["housingId"];
            this.personId = _data["personId"];
            this.isTenant = _data["isTenant"];
            this.contact = _data["contact"];
            this.person = _data["person"] ? PersonDto.fromJS(_data["person"]) : <any>undefined;
            this.housing = _data["housing"] ? HousingDto.fromJS(_data["housing"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HousingPersonDto {
        data = typeof data === 'object' ? data : {};
        let result = new HousingPersonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["housingId"] = this.housingId;
        data["personId"] = this.personId;
        data["isTenant"] = this.isTenant;
        data["contact"] = this.contact;
        data["person"] = this.person ? this.person.toJSON() : <any>undefined;
        data["housing"] = this.housing ? this.housing.toJSON() : <any>undefined;
        return data;
    }

    clone(): HousingPersonDto {
        const json = this.toJSON();
        let result = new HousingPersonDto();
        result.init(json);
        return result;
    }
}

export interface IHousingPersonDto {
    id: string;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    housingId: string;
    personId: string;
    isTenant: boolean;
    contact: boolean;
    person: PersonDto;
    housing: HousingDto;
}

export class HousingPersonDtoPagedResultDto implements IHousingPersonDtoPagedResultDto {
    items: HousingPersonDto[] | undefined;
    totalCount: number;

    constructor(data?: IHousingPersonDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(HousingPersonDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): HousingPersonDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new HousingPersonDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): HousingPersonDtoPagedResultDto {
        const json = this.toJSON();
        let result = new HousingPersonDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IHousingPersonDtoPagedResultDto {
    items: HousingPersonDto[] | undefined;
    totalCount: number;
}

export class Int64EntityDto implements IInt64EntityDto {
    id: number;

    constructor(data?: IInt64EntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Int64EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new Int64EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }

    clone(): Int64EntityDto {
        const json = this.toJSON();
        let result = new Int64EntityDto();
        result.init(json);
        return result;
    }
}

export interface IInt64EntityDto {
    id: number;
}

export class InventoryDto implements IInventoryDto {
    id: string;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    inventoryTypeId: string;
    accountBookId: string | undefined;
    quantity: number;
    serialNumber: string | undefined;
    description: string | undefined;
    inventoryType: InventoryTypeDto;

    constructor(data?: IInventoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.inventoryTypeId = _data["inventoryTypeId"];
            this.accountBookId = _data["accountBookId"];
            this.quantity = _data["quantity"];
            this.serialNumber = _data["serialNumber"];
            this.description = _data["description"];
            this.inventoryType = _data["inventoryType"] ? InventoryTypeDto.fromJS(_data["inventoryType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): InventoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new InventoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["inventoryTypeId"] = this.inventoryTypeId;
        data["accountBookId"] = this.accountBookId;
        data["quantity"] = this.quantity;
        data["serialNumber"] = this.serialNumber;
        data["description"] = this.description;
        data["inventoryType"] = this.inventoryType ? this.inventoryType.toJSON() : <any>undefined;
        return data;
    }

    clone(): InventoryDto {
        const json = this.toJSON();
        let result = new InventoryDto();
        result.init(json);
        return result;
    }
}

export interface IInventoryDto {
    id: string;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    inventoryTypeId: string;
    accountBookId: string | undefined;
    quantity: number;
    serialNumber: string | undefined;
    description: string | undefined;
    inventoryType: InventoryTypeDto;
}

export class InventoryDtoPagedResultDto implements IInventoryDtoPagedResultDto {
    items: InventoryDto[] | undefined;
    totalCount: number;

    constructor(data?: IInventoryDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(InventoryDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): InventoryDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new InventoryDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): InventoryDtoPagedResultDto {
        const json = this.toJSON();
        let result = new InventoryDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IInventoryDtoPagedResultDto {
    items: InventoryDto[] | undefined;
    totalCount: number;
}

export class InventoryGetAllDto implements IInventoryGetAllDto {
    inventoryTypeId: string;
    inventoryTypeName: string | undefined;
    serialNumber: string | undefined;
    quantity: number;
    quantityWithAccountBook: number;
    quantityTypeName: QuantityType;
    accountBookIds: string[] | undefined;

    constructor(data?: IInventoryGetAllDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.inventoryTypeId = _data["inventoryTypeId"];
            this.inventoryTypeName = _data["inventoryTypeName"];
            this.serialNumber = _data["serialNumber"];
            this.quantity = _data["quantity"];
            this.quantityWithAccountBook = _data["quantityWithAccountBook"];
            this.quantityTypeName = _data["quantityTypeName"];
            if (Array.isArray(_data["accountBookIds"])) {
                this.accountBookIds = [] as any;
                for (let item of _data["accountBookIds"])
                    this.accountBookIds.push(item);
            }
        }
    }

    static fromJS(data: any): InventoryGetAllDto {
        data = typeof data === 'object' ? data : {};
        let result = new InventoryGetAllDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inventoryTypeId"] = this.inventoryTypeId;
        data["inventoryTypeName"] = this.inventoryTypeName;
        data["serialNumber"] = this.serialNumber;
        data["quantity"] = this.quantity;
        data["quantityWithAccountBook"] = this.quantityWithAccountBook;
        data["quantityTypeName"] = this.quantityTypeName;
        if (Array.isArray(this.accountBookIds)) {
            data["accountBookIds"] = [];
            for (let item of this.accountBookIds)
                data["accountBookIds"].push(item);
        }
        return data;
    }

    clone(): InventoryGetAllDto {
        const json = this.toJSON();
        let result = new InventoryGetAllDto();
        result.init(json);
        return result;
    }
}

export interface IInventoryGetAllDto {
    inventoryTypeId: string;
    inventoryTypeName: string | undefined;
    serialNumber: string | undefined;
    quantity: number;
    quantityWithAccountBook: number;
    quantityTypeName: QuantityType;
    accountBookIds: string[] | undefined;
}

export class InventoryGetAllDtoPagedResultDto implements IInventoryGetAllDtoPagedResultDto {
    items: InventoryGetAllDto[] | undefined;
    totalCount: number;

    constructor(data?: IInventoryGetAllDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(InventoryGetAllDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): InventoryGetAllDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new InventoryGetAllDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): InventoryGetAllDtoPagedResultDto {
        const json = this.toJSON();
        let result = new InventoryGetAllDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IInventoryGetAllDtoPagedResultDto {
    items: InventoryGetAllDto[] | undefined;
    totalCount: number;
}

export class InventoryTypeDto implements IInventoryTypeDto {
    id: string;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    inventoryTypeName: string | undefined;
    quantityType: QuantityType;

    constructor(data?: IInventoryTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.inventoryTypeName = _data["inventoryTypeName"];
            this.quantityType = _data["quantityType"];
        }
    }

    static fromJS(data: any): InventoryTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new InventoryTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["inventoryTypeName"] = this.inventoryTypeName;
        data["quantityType"] = this.quantityType;
        return data;
    }

    clone(): InventoryTypeDto {
        const json = this.toJSON();
        let result = new InventoryTypeDto();
        result.init(json);
        return result;
    }
}

export interface IInventoryTypeDto {
    id: string;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    inventoryTypeName: string | undefined;
    quantityType: QuantityType;
}

export class InventoryTypeDtoPagedResultDto implements IInventoryTypeDtoPagedResultDto {
    items: InventoryTypeDto[] | undefined;
    totalCount: number;

    constructor(data?: IInventoryTypeDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(InventoryTypeDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): InventoryTypeDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new InventoryTypeDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): InventoryTypeDtoPagedResultDto {
        const json = this.toJSON();
        let result = new InventoryTypeDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IInventoryTypeDtoPagedResultDto {
    items: InventoryTypeDto[] | undefined;
    totalCount: number;
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data;
    }

    clone(): IsTenantAvailableInput {
        const json = this.toJSON();
        let result = new IsTenantAvailableInput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): IsTenantAvailableOutput {
        const json = this.toJSON();
        let result = new IsTenantAvailableOutput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;
}

export class LookUpDto implements ILookUpDto {
    value: string | undefined;
    label: string | undefined;

    constructor(data?: ILookUpDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): LookUpDto {
        data = typeof data === 'object' ? data : {};
        let result = new LookUpDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["label"] = this.label;
        return data;
    }

    clone(): LookUpDto {
        const json = this.toJSON();
        let result = new LookUpDto();
        result.init(json);
        return result;
    }
}

export interface ILookUpDto {
    value: string | undefined;
    label: string | undefined;
}

export class PagedAccountBookResultDto implements IPagedAccountBookResultDto {
    items: AccountBookGetAllOutput[] | undefined;
    totalCount: number;
    balance: number;
    lastAccountBookDate: moment.Moment | undefined;

    constructor(data?: IPagedAccountBookResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(AccountBookGetAllOutput.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.balance = _data["balance"];
            this.lastAccountBookDate = _data["lastAccountBookDate"] ? moment(_data["lastAccountBookDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PagedAccountBookResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedAccountBookResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["balance"] = this.balance;
        data["lastAccountBookDate"] = this.lastAccountBookDate ? this.lastAccountBookDate.toISOString() : <any>undefined;
        return data;
    }

    clone(): PagedAccountBookResultDto {
        const json = this.toJSON();
        let result = new PagedAccountBookResultDto();
        result.init(json);
        return result;
    }
}

export interface IPagedAccountBookResultDto {
    items: AccountBookGetAllOutput[] | undefined;
    totalCount: number;
    balance: number;
    lastAccountBookDate: moment.Moment | undefined;
}

export class PagedHousingPaymentPlanResultDto implements IPagedHousingPaymentPlanResultDto {
    items: HousingPaymentPlanDto[] | undefined;
    totalCount: number;
    balance: number;
    creditBalance: number;
    debtBalance: number;

    constructor(data?: IPagedHousingPaymentPlanResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(HousingPaymentPlanDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.balance = _data["balance"];
            this.creditBalance = _data["creditBalance"];
            this.debtBalance = _data["debtBalance"];
        }
    }

    static fromJS(data: any): PagedHousingPaymentPlanResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedHousingPaymentPlanResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["balance"] = this.balance;
        data["creditBalance"] = this.creditBalance;
        data["debtBalance"] = this.debtBalance;
        return data;
    }

    clone(): PagedHousingPaymentPlanResultDto {
        const json = this.toJSON();
        let result = new PagedHousingPaymentPlanResultDto();
        result.init(json);
        return result;
    }
}

export interface IPagedHousingPaymentPlanResultDto {
    items: HousingPaymentPlanDto[] | undefined;
    totalCount: number;
    balance: number;
    creditBalance: number;
    debtBalance: number;
}

export class PaymentAccountDashboardDto implements IPaymentAccountDashboardDto {
    paymentAccountName: string | undefined;
    balance: number;

    constructor(data?: IPaymentAccountDashboardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentAccountName = _data["paymentAccountName"];
            this.balance = _data["balance"];
        }
    }

    static fromJS(data: any): PaymentAccountDashboardDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentAccountDashboardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentAccountName"] = this.paymentAccountName;
        data["balance"] = this.balance;
        return data;
    }

    clone(): PaymentAccountDashboardDto {
        const json = this.toJSON();
        let result = new PaymentAccountDashboardDto();
        result.init(json);
        return result;
    }
}

export interface IPaymentAccountDashboardDto {
    paymentAccountName: string | undefined;
    balance: number;
}

export class PaymentAccountDto implements IPaymentAccountDto {
    id: string;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    accountName: string | undefined;
    paymentAccountType: PaymentAccountType;
    balance: number;
    description: string | undefined;
    personId: string | undefined;
    employeeId: string | undefined;
    iban: string | undefined;
    tenantIsOwner: boolean;
    firstTransferDateTime: moment.Moment | undefined;
    transferAmount: number | undefined;
    allowNegativeBalance: boolean;
    isActive: boolean;

    constructor(data?: IPaymentAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.accountName = _data["accountName"];
            this.paymentAccountType = _data["paymentAccountType"];
            this.balance = _data["balance"];
            this.description = _data["description"];
            this.personId = _data["personId"];
            this.employeeId = _data["employeeId"];
            this.iban = _data["iban"];
            this.tenantIsOwner = _data["tenantIsOwner"];
            this.firstTransferDateTime = _data["firstTransferDateTime"] ? moment(_data["firstTransferDateTime"].toString()) : <any>undefined;
            this.transferAmount = _data["transferAmount"];
            this.allowNegativeBalance = _data["allowNegativeBalance"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): PaymentAccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentAccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["accountName"] = this.accountName;
        data["paymentAccountType"] = this.paymentAccountType;
        data["balance"] = this.balance;
        data["description"] = this.description;
        data["personId"] = this.personId;
        data["employeeId"] = this.employeeId;
        data["iban"] = this.iban;
        data["tenantIsOwner"] = this.tenantIsOwner;
        data["firstTransferDateTime"] = this.firstTransferDateTime ? this.firstTransferDateTime.toISOString() : <any>undefined;
        data["transferAmount"] = this.transferAmount;
        data["allowNegativeBalance"] = this.allowNegativeBalance;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): PaymentAccountDto {
        const json = this.toJSON();
        let result = new PaymentAccountDto();
        result.init(json);
        return result;
    }
}

export interface IPaymentAccountDto {
    id: string;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    accountName: string | undefined;
    paymentAccountType: PaymentAccountType;
    balance: number;
    description: string | undefined;
    personId: string | undefined;
    employeeId: string | undefined;
    iban: string | undefined;
    tenantIsOwner: boolean;
    firstTransferDateTime: moment.Moment | undefined;
    transferAmount: number | undefined;
    allowNegativeBalance: boolean;
    isActive: boolean;
}

export class PaymentAccountDtoPagedResultDto implements IPaymentAccountDtoPagedResultDto {
    items: PaymentAccountDto[] | undefined;
    totalCount: number;

    constructor(data?: IPaymentAccountDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PaymentAccountDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PaymentAccountDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentAccountDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): PaymentAccountDtoPagedResultDto {
        const json = this.toJSON();
        let result = new PaymentAccountDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IPaymentAccountDtoPagedResultDto {
    items: PaymentAccountDto[] | undefined;
    totalCount: number;
}

export enum PaymentAccountType {
    Cash = 1,
    BankAccount = 2,
}

export class PaymentCategoryDashboardDto implements IPaymentCategoryDashboardDto {
    paymentCategoryName: string | undefined;
    totalAmount: number;

    constructor(data?: IPaymentCategoryDashboardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentCategoryName = _data["paymentCategoryName"];
            this.totalAmount = _data["totalAmount"];
        }
    }

    static fromJS(data: any): PaymentCategoryDashboardDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentCategoryDashboardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentCategoryName"] = this.paymentCategoryName;
        data["totalAmount"] = this.totalAmount;
        return data;
    }

    clone(): PaymentCategoryDashboardDto {
        const json = this.toJSON();
        let result = new PaymentCategoryDashboardDto();
        result.init(json);
        return result;
    }
}

export interface IPaymentCategoryDashboardDto {
    paymentCategoryName: string | undefined;
    totalAmount: number;
}

export class PaymentCategoryDto implements IPaymentCategoryDto {
    id: string;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    paymentCategoryName: string | undefined;
    isHousingDue: boolean;
    isValidForAllPeriods: boolean;
    defaultFromPaymentAccountId: string | undefined;
    defaultToPaymentAccountId: string | undefined;
    paymentCategoryType: PaymentCategoryType;
    defaultFromPaymentAccountName: string | undefined;
    defaultToPaymentAccountName: string | undefined;
    isActive: boolean;

    constructor(data?: IPaymentCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.paymentCategoryName = _data["paymentCategoryName"];
            this.isHousingDue = _data["isHousingDue"];
            this.isValidForAllPeriods = _data["isValidForAllPeriods"];
            this.defaultFromPaymentAccountId = _data["defaultFromPaymentAccountId"];
            this.defaultToPaymentAccountId = _data["defaultToPaymentAccountId"];
            this.paymentCategoryType = _data["paymentCategoryType"];
            this.defaultFromPaymentAccountName = _data["defaultFromPaymentAccountName"];
            this.defaultToPaymentAccountName = _data["defaultToPaymentAccountName"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): PaymentCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["paymentCategoryName"] = this.paymentCategoryName;
        data["isHousingDue"] = this.isHousingDue;
        data["isValidForAllPeriods"] = this.isValidForAllPeriods;
        data["defaultFromPaymentAccountId"] = this.defaultFromPaymentAccountId;
        data["defaultToPaymentAccountId"] = this.defaultToPaymentAccountId;
        data["paymentCategoryType"] = this.paymentCategoryType;
        data["defaultFromPaymentAccountName"] = this.defaultFromPaymentAccountName;
        data["defaultToPaymentAccountName"] = this.defaultToPaymentAccountName;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): PaymentCategoryDto {
        const json = this.toJSON();
        let result = new PaymentCategoryDto();
        result.init(json);
        return result;
    }
}

export interface IPaymentCategoryDto {
    id: string;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    paymentCategoryName: string | undefined;
    isHousingDue: boolean;
    isValidForAllPeriods: boolean;
    defaultFromPaymentAccountId: string | undefined;
    defaultToPaymentAccountId: string | undefined;
    paymentCategoryType: PaymentCategoryType;
    defaultFromPaymentAccountName: string | undefined;
    defaultToPaymentAccountName: string | undefined;
    isActive: boolean;
}

export class PaymentCategoryDtoPagedResultDto implements IPaymentCategoryDtoPagedResultDto {
    items: PaymentCategoryDto[] | undefined;
    totalCount: number;

    constructor(data?: IPaymentCategoryDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PaymentCategoryDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PaymentCategoryDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentCategoryDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): PaymentCategoryDtoPagedResultDto {
        const json = this.toJSON();
        let result = new PaymentCategoryDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IPaymentCategoryDtoPagedResultDto {
    items: PaymentCategoryDto[] | undefined;
    totalCount: number;
}

export enum PaymentCategoryType {
    Income = 1,
    Expense = 2,
    TransferBetweenAccounts = 3,
}

export class PeriodDto implements IPeriodDto {
    id: string;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    startDate: moment.Moment;
    isActive: boolean;
    endDate: moment.Moment | undefined;
    siteOrBlock: SiteOrBlock;
    blockId: string | undefined;

    constructor(data?: IPeriodDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.siteOrBlock = _data["siteOrBlock"];
            this.blockId = _data["blockId"];
        }
    }

    static fromJS(data: any): PeriodDto {
        data = typeof data === 'object' ? data : {};
        let result = new PeriodDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["siteOrBlock"] = this.siteOrBlock;
        data["blockId"] = this.blockId;
        return data;
    }

    clone(): PeriodDto {
        const json = this.toJSON();
        let result = new PeriodDto();
        result.init(json);
        return result;
    }
}

export interface IPeriodDto {
    id: string;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    startDate: moment.Moment;
    isActive: boolean;
    endDate: moment.Moment | undefined;
    siteOrBlock: SiteOrBlock;
    blockId: string | undefined;
}

export class PeriodDtoPagedResultDto implements IPeriodDtoPagedResultDto {
    items: PeriodDto[] | undefined;
    totalCount: number;

    constructor(data?: IPeriodDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PeriodDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PeriodDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PeriodDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): PeriodDtoPagedResultDto {
        const json = this.toJSON();
        let result = new PeriodDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IPeriodDtoPagedResultDto {
    items: PeriodDto[] | undefined;
    totalCount: number;
}

export class PermissionDto implements IPermissionDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;

    constructor(data?: IPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): PermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data;
    }

    clone(): PermissionDto {
        const json = this.toJSON();
        let result = new PermissionDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
}

export class PermissionDtoListResultDto implements IPermissionDtoListResultDto {
    items: PermissionDto[] | undefined;

    constructor(data?: IPermissionDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): PermissionDtoListResultDto {
        const json = this.toJSON();
        let result = new PermissionDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDtoListResultDto {
    items: PermissionDto[] | undefined;
}

export class PersonDto implements IPersonDto {
    id: string;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    name: string | undefined;
    phone1: string | undefined;
    phone2: string | undefined;

    constructor(data?: IPersonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.name = _data["name"];
            this.phone1 = _data["phone1"];
            this.phone2 = _data["phone2"];
        }
    }

    static fromJS(data: any): PersonDto {
        data = typeof data === 'object' ? data : {};
        let result = new PersonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["name"] = this.name;
        data["phone1"] = this.phone1;
        data["phone2"] = this.phone2;
        return data;
    }

    clone(): PersonDto {
        const json = this.toJSON();
        let result = new PersonDto();
        result.init(json);
        return result;
    }
}

export interface IPersonDto {
    id: string;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    name: string | undefined;
    phone1: string | undefined;
    phone2: string | undefined;
}

export class PersonDtoPagedResultDto implements IPersonDtoPagedResultDto {
    items: PersonDto[] | undefined;
    totalCount: number;

    constructor(data?: IPersonDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PersonDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PersonDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PersonDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): PersonDtoPagedResultDto {
        const json = this.toJSON();
        let result = new PersonDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IPersonDtoPagedResultDto {
    items: PersonDto[] | undefined;
    totalCount: number;
}

export enum QuantityType {
    Piece = 1,
    Kilogram = 2,
    Litre = 3,
}

export class RegisterInput implements IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.password = _data["password"];
            this.captchaResponse = _data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["captchaResponse"] = this.captchaResponse;
        return data;
    }

    clone(): RegisterInput {
        const json = this.toJSON();
        let result = new RegisterInput();
        result.init(json);
        return result;
    }
}

export interface IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin: boolean;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canLogin = _data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data;
    }

    clone(): RegisterOutput {
        const json = this.toJSON();
        let result = new RegisterOutput();
        result.init(json);
        return result;
    }
}

export interface IRegisterOutput {
    canLogin: boolean;
}

export class ReportLine implements IReportLine {
    description: string | undefined;
    amount: string | undefined;

    constructor(data?: IReportLine) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): ReportLine {
        data = typeof data === 'object' ? data : {};
        let result = new ReportLine();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["amount"] = this.amount;
        return data;
    }

    clone(): ReportLine {
        const json = this.toJSON();
        let result = new ReportLine();
        result.init(json);
        return result;
    }
}

export interface IReportLine {
    description: string | undefined;
    amount: string | undefined;
}

export class ResetPasswordDto implements IResetPasswordDto {
    adminPassword: string;
    userId: number;
    newPassword: string;

    constructor(data?: IResetPasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adminPassword = _data["adminPassword"];
            this.userId = _data["userId"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adminPassword"] = this.adminPassword;
        data["userId"] = this.userId;
        data["newPassword"] = this.newPassword;
        return data;
    }

    clone(): ResetPasswordDto {
        const json = this.toJSON();
        let result = new ResetPasswordDto();
        result.init(json);
        return result;
    }
}

export interface IResetPasswordDto {
    adminPassword: string;
    userId: number;
    newPassword: string;
}

export enum ResidentOrOwner {
    Resident = 1,
    Owner = 2,
}

export class RoleDto implements IRoleDto {
    id: number;
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.normalizedName = _data["normalizedName"];
            this.description = _data["description"];
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions.push(item);
            }
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        return data;
    }

    clone(): RoleDto {
        const json = this.toJSON();
        let result = new RoleDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDto {
    id: number;
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
}

export class RoleDtoListResultDto implements IRoleDtoListResultDto {
    items: RoleDto[] | undefined;

    constructor(data?: IRoleDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): RoleDtoListResultDto {
        const json = this.toJSON();
        let result = new RoleDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDtoListResultDto {
    items: RoleDto[] | undefined;
}

export class RoleDtoPagedResultDto implements IRoleDtoPagedResultDto {
    items: RoleDto[] | undefined;
    totalCount: number;

    constructor(data?: IRoleDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RoleDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): RoleDtoPagedResultDto {
        const json = this.toJSON();
        let result = new RoleDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDtoPagedResultDto {
    items: RoleDto[] | undefined;
    totalCount: number;
}

export class RoleEditDto implements IRoleEditDto {
    id: number;
    name: string;
    displayName: string;
    description: string | undefined;
    isStatic: boolean;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isStatic = _data["isStatic"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isStatic"] = this.isStatic;
        return data;
    }

    clone(): RoleEditDto {
        const json = this.toJSON();
        let result = new RoleEditDto();
        result.init(json);
        return result;
    }
}

export interface IRoleEditDto {
    id: number;
    name: string;
    displayName: string;
    description: string | undefined;
    isStatic: boolean;
}

export class RoleListDto implements IRoleListDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: moment.Moment;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isStatic = _data["isStatic"];
            this.isDefault = _data["isDefault"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data;
    }

    clone(): RoleListDto {
        const json = this.toJSON();
        let result = new RoleListDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: moment.Moment;
}

export class RoleListDtoListResultDto implements IRoleListDtoListResultDto {
    items: RoleListDto[] | undefined;

    constructor(data?: IRoleListDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleListDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): RoleListDtoListResultDto {
        const json = this.toJSON();
        let result = new RoleListDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDtoListResultDto {
    items: RoleListDto[] | undefined;
}

export enum SiteOrBlock {
    Site = 1,
    Block = 2,
}

export enum TenantAvailabilityState {
    Available = 1,
    InActive = 2,
    NotFound = 3,
}

export class TenantDto implements ITenantDto {
    id: number;
    tenancyName: string;
    name: string;
    isActive: boolean;

    constructor(data?: ITenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): TenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): TenantDto {
        const json = this.toJSON();
        let result = new TenantDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDto {
    id: number;
    tenancyName: string;
    name: string;
    isActive: boolean;
}

export class TenantDtoPagedResultDto implements ITenantDtoPagedResultDto {
    items: TenantDto[] | undefined;
    totalCount: number;

    constructor(data?: ITenantDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(TenantDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): TenantDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): TenantDtoPagedResultDto {
        const json = this.toJSON();
        let result = new TenantDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDtoPagedResultDto {
    items: TenantDto[] | undefined;
    totalCount: number;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    id: number;
    tenancyName: string | undefined;
    name: string | undefined;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        return data;
    }

    clone(): TenantLoginInfoDto {
        const json = this.toJSON();
        let result = new TenantLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface ITenantLoginInfoDto {
    id: number;
    tenancyName: string | undefined;
    name: string | undefined;
}

export class TotalHousingDueStatsDto implements ITotalHousingDueStatsDto {
    totalHousingDueDefinition: number;
    totalHousingDuePayment: number;

    constructor(data?: ITotalHousingDueStatsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalHousingDueDefinition = _data["totalHousingDueDefinition"];
            this.totalHousingDuePayment = _data["totalHousingDuePayment"];
        }
    }

    static fromJS(data: any): TotalHousingDueStatsDto {
        data = typeof data === 'object' ? data : {};
        let result = new TotalHousingDueStatsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalHousingDueDefinition"] = this.totalHousingDueDefinition;
        data["totalHousingDuePayment"] = this.totalHousingDuePayment;
        return data;
    }

    clone(): TotalHousingDueStatsDto {
        const json = this.toJSON();
        let result = new TotalHousingDueStatsDto();
        result.init(json);
        return result;
    }
}

export interface ITotalHousingDueStatsDto {
    totalHousingDueDefinition: number;
    totalHousingDuePayment: number;
}

export class UpdateAccountBookDto implements IUpdateAccountBookDto {
    id: string;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    processDateString: string | undefined;
    paymentCategoryId: string;
    fromPaymentAccountId: string | undefined;
    toPaymentAccountId: string | undefined;
    amount: number;
    description: string | undefined;
    documentDateTimeString: string | undefined;
    documentNumber: string | undefined;
    newAccountBookFileUrls: string[] | undefined;
    deletedAccountBookFileUrls: string[] | undefined;
    inventories: CreateInventoryDto[] | undefined;

    constructor(data?: IUpdateAccountBookDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.processDateString = _data["processDateString"];
            this.paymentCategoryId = _data["paymentCategoryId"];
            this.fromPaymentAccountId = _data["fromPaymentAccountId"];
            this.toPaymentAccountId = _data["toPaymentAccountId"];
            this.amount = _data["amount"];
            this.description = _data["description"];
            this.documentDateTimeString = _data["documentDateTimeString"];
            this.documentNumber = _data["documentNumber"];
            if (Array.isArray(_data["newAccountBookFileUrls"])) {
                this.newAccountBookFileUrls = [] as any;
                for (let item of _data["newAccountBookFileUrls"])
                    this.newAccountBookFileUrls.push(item);
            }
            if (Array.isArray(_data["deletedAccountBookFileUrls"])) {
                this.deletedAccountBookFileUrls = [] as any;
                for (let item of _data["deletedAccountBookFileUrls"])
                    this.deletedAccountBookFileUrls.push(item);
            }
            if (Array.isArray(_data["inventories"])) {
                this.inventories = [] as any;
                for (let item of _data["inventories"])
                    this.inventories.push(CreateInventoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateAccountBookDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAccountBookDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["processDateString"] = this.processDateString;
        data["paymentCategoryId"] = this.paymentCategoryId;
        data["fromPaymentAccountId"] = this.fromPaymentAccountId;
        data["toPaymentAccountId"] = this.toPaymentAccountId;
        data["amount"] = this.amount;
        data["description"] = this.description;
        data["documentDateTimeString"] = this.documentDateTimeString;
        data["documentNumber"] = this.documentNumber;
        if (Array.isArray(this.newAccountBookFileUrls)) {
            data["newAccountBookFileUrls"] = [];
            for (let item of this.newAccountBookFileUrls)
                data["newAccountBookFileUrls"].push(item);
        }
        if (Array.isArray(this.deletedAccountBookFileUrls)) {
            data["deletedAccountBookFileUrls"] = [];
            for (let item of this.deletedAccountBookFileUrls)
                data["deletedAccountBookFileUrls"].push(item);
        }
        if (Array.isArray(this.inventories)) {
            data["inventories"] = [];
            for (let item of this.inventories)
                data["inventories"].push(item.toJSON());
        }
        return data;
    }

    clone(): UpdateAccountBookDto {
        const json = this.toJSON();
        let result = new UpdateAccountBookDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateAccountBookDto {
    id: string;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    processDateString: string | undefined;
    paymentCategoryId: string;
    fromPaymentAccountId: string | undefined;
    toPaymentAccountId: string | undefined;
    amount: number;
    description: string | undefined;
    documentDateTimeString: string | undefined;
    documentNumber: string | undefined;
    newAccountBookFileUrls: string[] | undefined;
    deletedAccountBookFileUrls: string[] | undefined;
    inventories: CreateInventoryDto[] | undefined;
}

export class UpdateBlockDto implements IUpdateBlockDto {
    id: string;
    blockName: string | undefined;

    constructor(data?: IUpdateBlockDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.blockName = _data["blockName"];
        }
    }

    static fromJS(data: any): UpdateBlockDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateBlockDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["blockName"] = this.blockName;
        return data;
    }

    clone(): UpdateBlockDto {
        const json = this.toJSON();
        let result = new UpdateBlockDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateBlockDto {
    id: string;
    blockName: string | undefined;
}

export class UpdateHousingCategoryDto implements IUpdateHousingCategoryDto {
    id: string;
    housingCategoryName: string | undefined;

    constructor(data?: IUpdateHousingCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.housingCategoryName = _data["housingCategoryName"];
        }
    }

    static fromJS(data: any): UpdateHousingCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateHousingCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["housingCategoryName"] = this.housingCategoryName;
        return data;
    }

    clone(): UpdateHousingCategoryDto {
        const json = this.toJSON();
        let result = new UpdateHousingCategoryDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateHousingCategoryDto {
    id: string;
    housingCategoryName: string | undefined;
}

export class UpdateHousingDto implements IUpdateHousingDto {
    id: string;
    blockId: string;
    apartment: string | undefined;
    housingCategoryId: string;
    tenantIsResiding: boolean;
    deleteTransferForHousingDue: boolean;
    transferIsForResidentOrOwner: ResidentOrOwner;
    transferAmount: number | undefined;
    transferIsDebt: boolean;
    transferDateString: string | undefined;
    transferDescription: string | undefined;

    constructor(data?: IUpdateHousingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.blockId = _data["blockId"];
            this.apartment = _data["apartment"];
            this.housingCategoryId = _data["housingCategoryId"];
            this.tenantIsResiding = _data["tenantIsResiding"];
            this.deleteTransferForHousingDue = _data["deleteTransferForHousingDue"];
            this.transferIsForResidentOrOwner = _data["transferIsForResidentOrOwner"];
            this.transferAmount = _data["transferAmount"];
            this.transferIsDebt = _data["transferIsDebt"];
            this.transferDateString = _data["transferDateString"];
            this.transferDescription = _data["transferDescription"];
        }
    }

    static fromJS(data: any): UpdateHousingDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateHousingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["blockId"] = this.blockId;
        data["apartment"] = this.apartment;
        data["housingCategoryId"] = this.housingCategoryId;
        data["tenantIsResiding"] = this.tenantIsResiding;
        data["deleteTransferForHousingDue"] = this.deleteTransferForHousingDue;
        data["transferIsForResidentOrOwner"] = this.transferIsForResidentOrOwner;
        data["transferAmount"] = this.transferAmount;
        data["transferIsDebt"] = this.transferIsDebt;
        data["transferDateString"] = this.transferDateString;
        data["transferDescription"] = this.transferDescription;
        return data;
    }

    clone(): UpdateHousingDto {
        const json = this.toJSON();
        let result = new UpdateHousingDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateHousingDto {
    id: string;
    blockId: string;
    apartment: string | undefined;
    housingCategoryId: string;
    tenantIsResiding: boolean;
    deleteTransferForHousingDue: boolean;
    transferIsForResidentOrOwner: ResidentOrOwner;
    transferAmount: number | undefined;
    transferIsDebt: boolean;
    transferDateString: string | undefined;
    transferDescription: string | undefined;
}

export class UpdateHousingPaymentPlanDto implements IUpdateHousingPaymentPlanDto {
    id: string;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    housingPaymentPlanDateString: string | undefined;
    amount: number;
    description: string | undefined;

    constructor(data?: IUpdateHousingPaymentPlanDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.housingPaymentPlanDateString = _data["housingPaymentPlanDateString"];
            this.amount = _data["amount"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpdateHousingPaymentPlanDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateHousingPaymentPlanDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["housingPaymentPlanDateString"] = this.housingPaymentPlanDateString;
        data["amount"] = this.amount;
        data["description"] = this.description;
        return data;
    }

    clone(): UpdateHousingPaymentPlanDto {
        const json = this.toJSON();
        let result = new UpdateHousingPaymentPlanDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateHousingPaymentPlanDto {
    id: string;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    housingPaymentPlanDateString: string | undefined;
    amount: number;
    description: string | undefined;
}

export class UpdateHousingPaymentPlanGroupDto implements IUpdateHousingPaymentPlanGroupDto {
    id: string;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    housingPaymentPlanGroupName: string | undefined;
    defaultToPaymentAccountId: string;

    constructor(data?: IUpdateHousingPaymentPlanGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.housingPaymentPlanGroupName = _data["housingPaymentPlanGroupName"];
            this.defaultToPaymentAccountId = _data["defaultToPaymentAccountId"];
        }
    }

    static fromJS(data: any): UpdateHousingPaymentPlanGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateHousingPaymentPlanGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["housingPaymentPlanGroupName"] = this.housingPaymentPlanGroupName;
        data["defaultToPaymentAccountId"] = this.defaultToPaymentAccountId;
        return data;
    }

    clone(): UpdateHousingPaymentPlanGroupDto {
        const json = this.toJSON();
        let result = new UpdateHousingPaymentPlanGroupDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateHousingPaymentPlanGroupDto {
    id: string;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    housingPaymentPlanGroupName: string | undefined;
    defaultToPaymentAccountId: string;
}

export class UpdateInventoryDto implements IUpdateInventoryDto {
    id: string;
    inventoryTypeId: string;
    accountBookId: string | undefined;
    quantity: number;
    serialNumber: string | undefined;
    description: string | undefined;

    constructor(data?: IUpdateInventoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.inventoryTypeId = _data["inventoryTypeId"];
            this.accountBookId = _data["accountBookId"];
            this.quantity = _data["quantity"];
            this.serialNumber = _data["serialNumber"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpdateInventoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateInventoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["inventoryTypeId"] = this.inventoryTypeId;
        data["accountBookId"] = this.accountBookId;
        data["quantity"] = this.quantity;
        data["serialNumber"] = this.serialNumber;
        data["description"] = this.description;
        return data;
    }

    clone(): UpdateInventoryDto {
        const json = this.toJSON();
        let result = new UpdateInventoryDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateInventoryDto {
    id: string;
    inventoryTypeId: string;
    accountBookId: string | undefined;
    quantity: number;
    serialNumber: string | undefined;
    description: string | undefined;
}

export class UpdateInventoryTypeDto implements IUpdateInventoryTypeDto {
    id: string;
    inventoryTypeName: string | undefined;
    quantityType: QuantityType;

    constructor(data?: IUpdateInventoryTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.inventoryTypeName = _data["inventoryTypeName"];
            this.quantityType = _data["quantityType"];
        }
    }

    static fromJS(data: any): UpdateInventoryTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateInventoryTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["inventoryTypeName"] = this.inventoryTypeName;
        data["quantityType"] = this.quantityType;
        return data;
    }

    clone(): UpdateInventoryTypeDto {
        const json = this.toJSON();
        let result = new UpdateInventoryTypeDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateInventoryTypeDto {
    id: string;
    inventoryTypeName: string | undefined;
    quantityType: QuantityType;
}

export class UpdatePaymentAccountDto implements IUpdatePaymentAccountDto {
    id: string;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    accountName: string | undefined;
    description: string | undefined;
    personId: string | undefined;
    employeeId: string | undefined;
    iban: string | undefined;
    tenantIsOwner: boolean;
    allowNegativeBalance: boolean;
    isActive: boolean;

    constructor(data?: IUpdatePaymentAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.accountName = _data["accountName"];
            this.description = _data["description"];
            this.personId = _data["personId"];
            this.employeeId = _data["employeeId"];
            this.iban = _data["iban"];
            this.tenantIsOwner = _data["tenantIsOwner"];
            this.allowNegativeBalance = _data["allowNegativeBalance"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdatePaymentAccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePaymentAccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["accountName"] = this.accountName;
        data["description"] = this.description;
        data["personId"] = this.personId;
        data["employeeId"] = this.employeeId;
        data["iban"] = this.iban;
        data["tenantIsOwner"] = this.tenantIsOwner;
        data["allowNegativeBalance"] = this.allowNegativeBalance;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): UpdatePaymentAccountDto {
        const json = this.toJSON();
        let result = new UpdatePaymentAccountDto();
        result.init(json);
        return result;
    }
}

export interface IUpdatePaymentAccountDto {
    id: string;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    accountName: string | undefined;
    description: string | undefined;
    personId: string | undefined;
    employeeId: string | undefined;
    iban: string | undefined;
    tenantIsOwner: boolean;
    allowNegativeBalance: boolean;
    isActive: boolean;
}

export class UpdatePaymentCategoryDto implements IUpdatePaymentCategoryDto {
    id: string;
    paymentCategoryName: string | undefined;
    defaultFromPaymentAccountId: string | undefined;
    defaultToPaymentAccountId: string | undefined;

    constructor(data?: IUpdatePaymentCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.paymentCategoryName = _data["paymentCategoryName"];
            this.defaultFromPaymentAccountId = _data["defaultFromPaymentAccountId"];
            this.defaultToPaymentAccountId = _data["defaultToPaymentAccountId"];
        }
    }

    static fromJS(data: any): UpdatePaymentCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePaymentCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["paymentCategoryName"] = this.paymentCategoryName;
        data["defaultFromPaymentAccountId"] = this.defaultFromPaymentAccountId;
        data["defaultToPaymentAccountId"] = this.defaultToPaymentAccountId;
        return data;
    }

    clone(): UpdatePaymentCategoryDto {
        const json = this.toJSON();
        let result = new UpdatePaymentCategoryDto();
        result.init(json);
        return result;
    }
}

export interface IUpdatePaymentCategoryDto {
    id: string;
    paymentCategoryName: string | undefined;
    defaultFromPaymentAccountId: string | undefined;
    defaultToPaymentAccountId: string | undefined;
}

export class UpdatePeriodDto implements IUpdatePeriodDto {
    id: string;
    name: string | undefined;
    startDateString: string | undefined;
    endDateString: string | undefined;

    constructor(data?: IUpdatePeriodDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.startDateString = _data["startDateString"];
            this.endDateString = _data["endDateString"];
        }
    }

    static fromJS(data: any): UpdatePeriodDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePeriodDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["startDateString"] = this.startDateString;
        data["endDateString"] = this.endDateString;
        return data;
    }

    clone(): UpdatePeriodDto {
        const json = this.toJSON();
        let result = new UpdatePeriodDto();
        result.init(json);
        return result;
    }
}

export interface IUpdatePeriodDto {
    id: string;
    name: string | undefined;
    startDateString: string | undefined;
    endDateString: string | undefined;
}

export class UpdatePersonDto implements IUpdatePersonDto {
    id: string;
    firstName: string | undefined;
    lastName: string | undefined;
    phone1: string | undefined;
    phone2: string | undefined;

    constructor(data?: IUpdatePersonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.phone1 = _data["phone1"];
            this.phone2 = _data["phone2"];
        }
    }

    static fromJS(data: any): UpdatePersonDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePersonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["phone1"] = this.phone1;
        data["phone2"] = this.phone2;
        return data;
    }

    clone(): UpdatePersonDto {
        const json = this.toJSON();
        let result = new UpdatePersonDto();
        result.init(json);
        return result;
    }
}

export interface IUpdatePersonDto {
    id: string;
    firstName: string | undefined;
    lastName: string | undefined;
    phone1: string | undefined;
    phone2: string | undefined;
}

export class UserDto implements IUserDto {
    id: number;
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment;
    roleNames: string[] | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.isActive = _data["isActive"];
            this.fullName = _data["fullName"];
            this.lastLoginTime = _data["lastLoginTime"] ? moment(_data["lastLoginTime"].toString()) : <any>undefined;
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames.push(item);
            }
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["fullName"] = this.fullName;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        return data;
    }

    clone(): UserDto {
        const json = this.toJSON();
        let result = new UserDto();
        result.init(json);
        return result;
    }
}

export interface IUserDto {
    id: number;
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment;
    roleNames: string[] | undefined;
}

export class UserDtoPagedResultDto implements IUserDtoPagedResultDto {
    items: UserDto[] | undefined;
    totalCount: number;

    constructor(data?: IUserDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(UserDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): UserDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): UserDtoPagedResultDto {
        const json = this.toJSON();
        let result = new UserDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IUserDtoPagedResultDto {
    items: UserDto[] | undefined;
    totalCount: number;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    id: number;
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        return data;
    }

    clone(): UserLoginInfoDto {
        const json = this.toJSON();
        let result = new UserLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginInfoDto {
    id: number;
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}